<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fruit Cut ‚Äî Robust Build (Debug Enabled)</title>
<style>
  :root{ --btn:#111; --btnHover:#333; --accent:#22c55e; }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial,Helvetica;margin:12px;background:#f4f7fb;color:#111}
  .container{max-width:980px;margin:0 auto}
  h1{margin:6px 0 10px}
  .hud{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:8px}
  .stat{background:#fff;padding:8px 12px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.04);display:flex;align-items:center}
  #gameWrapper{position:relative;height:520px;border-radius:12px;overflow:hidden;border:1px solid rgba(0,0,0,0.06);background-color:#e9e6e1}
  #gameArea{position:absolute;inset:0;touch-action:none;overflow:visible}
  canvas{position:absolute;inset:0;pointer-events:none}
  .fruit{position:absolute;will-change:transform;z-index:600}
  img.fruit-img{display:block;pointer-events:none}
  .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
  button{padding:8px 12px;border-radius:8px;border:0;background:var(--btn);color:#fff;cursor:pointer;font-weight:600}
  .ghost{background:#fff;color:#111;border:1px solid #e6e6e6;padding:8px 12px;border-radius:8px}
  .debugBox{position:fixed;right:12px;top:12px;z-index:99999;background:rgba(0,0,0,0.85);color:#fff;padding:10px;max-width:36%;font-size:12px;border-radius:8px;line-height:1.25;max-height:60vh;overflow:auto}
  .debugLine{font-family:monospace;font-size:12px;margin:2px 0}
  #bigStart{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:200;background:rgba(0,0,0,0.85);color:#fff;padding:16px 22px;border-radius:10px;cursor:pointer}
  @media (max-width:700px){ #gameWrapper{height:420px} .debugBox{display:block;left:6px;right:6px;max-width:unset} }
</style>
</head>
<body>
<div class="container">
  <h1>üçâ Fruit Cut ‚Äî Debug Build</h1>

  <div class="hud">
    <div class="stat">Score: <strong id="scoreEl">0</strong></div>
    <div class="stat">Lives: <strong id="livesEl">3</strong></div>
    <div class="stat">Coins: <strong id="coinsEl">0</strong></div>
    <div style="flex:1"></div>
    <div class="stat">Level: <strong id="levelEl">1</strong></div>
  </div>

  <div id="gameWrapper">
    <div id="gameArea" aria-label="Game area ‚Äî swipe to cut fruits"></div>
    <canvas id="splatCanvas" style="z-index:40"></canvas>
    <canvas id="bladeCanvas" style="z-index:900"></canvas>

    <div id="bigStart">START</div>
  </div>

  <div class="controls">
    <button id="startBtn" class="ghost">Start</button>
    <button id="pauseBtn" class="ghost" disabled>Pause</button>
    <button id="restartBtn" class="ghost">Restart</button>
    <button id="consoleToggle" class="ghost">Toggle Console</button>
  </div>

  <p style="color:#666;margin-top:12px">If the game doesn't start, open the debug box (Toggle Console) and share the top errors here.</p>
</div>

<div id="debug" class="debugBox" style="display:none"></div>

<!-- attempt to load eruda but don't let it break execution -->
<script>
(function loadErudaSafely(){
  try{
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/eruda';
    s.onload = function(){ try{ eruda.init(); console.log('eruda loaded'); }catch(e){ console.warn('eruda init failed', e); } };
    s.onerror = function(){ console.warn('eruda load failed'); };
    document.head.appendChild(s);
  }catch(e){ console.warn('eruda injection fail', e); }
})();
</script>

<script>
/* Robust game script with defensive guards and on-screen debug output.
   Replace images folder with your PNGs (apple.png etc).
*/

(function(){
  // ===== Debug UI (always available) =====
  const debugBox = document.getElementById('debug');
  function showDebug(){ debugBox.style.display = 'block'; }
  function hideDebug(){ debugBox.style.display = 'none'; }
  document.getElementById('consoleToggle').addEventListener('click', ()=> debugBox.style.display = (debugBox.style.display === 'none' ? 'block' : 'none'));

  function dbg(msg, level='log'){
    const time = new Date().toLocaleTimeString();
    const div = document.createElement('div'); div.className='debugLine'; div.textContent = `[${time}] ${msg}`;
    if(level === 'error') div.style.color = '#ffb3b3';
    debugBox.appendChild(div);
    // keep only last 120 lines
    while(debugBox.childElementCount > 140) debugBox.removeChild(debugBox.firstChild);
    console[level] ? console[level]('[FruitCut]', msg) : console.log('[FruitCut]', msg);
  }

  // capture global errors
  window.addEventListener('error', function(ev){
    dbg('Error: ' + (ev && ev.message ? ev.message : String(ev)), 'error');
  });
  window.addEventListener('unhandledrejection', function(ev){
    dbg('Promise Rejection: ' + (ev.reason ? (ev.reason.message || ev.reason) : JSON.stringify(ev)), 'error');
  });

  // ===== DOM refs =====
  const gameArea = document.getElementById('gameArea');
  const bladeCanvas = document.getElementById('bladeCanvas');
  const splatCanvas = document.getElementById('splatCanvas');
  const scoreEl = document.getElementById('scoreEl');
  const livesEl = document.getElementById('livesEl');
  const coinsEl = document.getElementById('coinsEl');
  const levelEl = document.getElementById('levelEl');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const bigStart = document.getElementById('bigStart');

  if(!gameArea){
    dbg('Missing #gameArea element ‚Äî cannot run', 'error');
    showDebug();
    return;
  }

  // ===== Config & State (single declarations) =====
  const IMAGES = ["apple.png","banana.png","mango.png","orange.png","watermelon.png","strawberry.png","pineapple.png","papaya.png","pomegranate.png"];
  const BOMB = "bomb.png"; const ALL = IMAGES.concat([BOMB]);

  const GRAVITY = 0.24;
  const SPAWN_BASE = 1400;
  let spawnInterval = SPAWN_BASE; // declared once
  const MAX_ACTIVE = 5;
  const MAX_BLADE = 12;
  const PTR_THROTTLE = 28;

  const COMBO_WINDOW_MS = 700; const COMBO_MULT = [1,1.2,1.5,2.0,3.0];

  let score = 0, lives = 3, coins = 0, level = 1;
  let running = false, spawnTimer = null;
  const active = []; const POOL = []; const JUICE_POOL = []; const CACHE = {};
  let lastSlices = [];

  // canvas contexts
  let bladeCtx = bladeCanvas.getContext('2d');
  let splatCtx = splatCanvas.getContext('2d');

  // responsive area
  let areaW = 480, areaH = 520;
  function resizeAll(){
    try{
      const r = gameArea.getBoundingClientRect();
      areaW = Math.max(1, Math.floor(r.width)); areaH = Math.max(1, Math.floor(r.height));
      bladeCanvas.width = areaW; bladeCanvas.height = areaH;
      splatCanvas.width = areaW; splatCanvas.height = areaH;
      bladeCtx = bladeCanvas.getContext('2d'); splatCtx = splatCanvas.getContext('2d');
      dbg('Resized area to ' + areaW + 'x' + areaH);
    }catch(e){ dbg('resizeAll error: ' + e, 'error'); }
  }
  window.addEventListener('resize', resizeAll);
  setTimeout(resizeAll, 80);

  // ===== Preload with timeout fallback =====
  async function preloadAll(timeoutMs = 3000){
    dbg('Starting preload of images (timeout ' + timeoutMs + 'ms)...');
    const list = ALL.slice();
    const promises = list.map(name => new Promise(res => {
      try{
        const img = new Image();
        img.onload = async ()=> { try{ if(img.decode) await img.decode(); }catch(e){} CACHE[name] = img; dbg('loaded ' + name); res({name, ok:true}); };
        img.onerror = ()=> { dbg('failed to load ' + name); res({name, ok:false}); };
        img.src = 'images/' + name;
      }catch(err){ dbg('preload error for ' + name + ': ' + err, 'error'); res({name, ok:false}); }
    }));
    // race between Promise.all and timeout
    const allPromise = Promise.all(promises);
    const timeout = new Promise(res => setTimeout(()=> res('__timeout__'), timeoutMs));
    const r = await Promise.race([allPromise, timeout]);
    if(r === '__timeout__'){
      dbg('Preload timed out; continuing with what we have');
      try{ await Promise.all(promises); }catch(e){ /* ignore */ }
    } else {
      dbg('Preload finished quickly');
    }
  }

  // ===== Pools =====
  function makeFruitEl(){
    const el = document.createElement('div'); el.className='fruit'; el.style.position='absolute';
    const img = document.createElement('img'); img.className='fruit-img'; img.draggable=false; el.appendChild(img);
    return el;
  }
  function acquireFruit(){ return POOL.length ? POOL.pop() : makeFruitEl(); }
  function releaseFruit(el){ try{ const img = el.querySelector('img'); if(img) img.src=''; if(el.parentNode) el.parentNode.removeChild(el); POOL.push(el);}catch(e){ dbg('releaseFruit err: '+e,'error'); } }

  function makeJuice(){ const j = document.createElement('div'); j.className='juice'; j.style.position='absolute'; j.style.pointerEvents='none'; j.style.zIndex=950; j.style.borderRadius='50%'; return j; }
  function acquireJuice(){ return JUICE_POOL.length ? JUICE_POOL.pop() : makeJuice(); }
  function releaseJuice(j){ if(j.parentNode) j.parentNode.removeChild(j); JUICE_POOL.push(j); }

  // splat canvas list
  const splats = []; const SPLAT_MAX = 48;
  function addSplat(x,y,color,size,strength=1){ if(splats.length >= SPLAT_MAX) splats.shift(); splats.push({x,y,color,size,alpha:0.95*strength,life:1}); }

  function drawSplats(){
    if(!splatCtx) return;
    splatCtx.save();
    splatCtx.fillStyle = 'rgba(233,230,225,0.03)'; splatCtx.fillRect(0,0,splatCanvas.width,splatCanvas.height);
    for(let i=splats.length-1;i>=0;i--){
      const s = splats[i];
      const g = splatCtx.createRadialGradient(s.x,s.y,0,s.x,s.y,s.size);
      g.addColorStop(0, `rgba(${s.color.r},${s.color.g},${s.color.b},${s.alpha})`);
      g.addColorStop(1, `rgba(${s.color.r},${s.color.g},${s.color.b},0)`);
      splatCtx.fillStyle = g; splatCtx.fillRect(s.x-s.size,s.y-s.size,s.size*2,s.size*2);
      s.alpha *= 0.95; s.life -= 0.02; if(s.alpha < 0.02 || s.life < 0) splats.splice(i,1);
    }
    splatCtx.restore();
  }

  // ===== Spawn (from bottom, smaller & slower) =====
  function spawnOne(typeName){
    try{
      if(!running) return;
      if(active.length >= MAX_ACTIVE) return;
      const name = typeName || (Math.random() < 0.92 ? IMAGES[Math.floor(Math.random()*IMAGES.length)] : BOMB);
      const el = acquireFruit(); const img = el.querySelector('img');
      const desiredWidth = Math.max(64, Math.min(110, Math.floor(areaW * 0.12)));
      if(CACHE[name]){ img.src = CACHE[name].src; const nat = CACHE[name]; const ar = (nat.naturalHeight && nat.naturalWidth) ? (nat.naturalHeight / nat.naturalWidth) : 1; img.style.width = desiredWidth + 'px'; img.style.height = Math.round(desiredWidth * ar) + 'px'; el.style.width = img.style.width; el.style.height = img.style.height; } else { img.src = 'images/' + name; img.style.width = desiredWidth + 'px'; img.style.height = 'auto'; el.style.width = img.style.width; el.style.height = img.style.height; }
      const startX = Math.floor(Math.random() * Math.max(1, areaW - parseFloat(el.style.width) - 40)) + 20;
      const startY = -24;
      el.style.left = startX + 'px'; el.style.bottom = startY + 'px'; el.dataset.type = name; gameArea.appendChild(el);
      const vy = 12 + Math.random() * 2.4; const vx = (Math.random() - 0.5) * 2.2; const rot = (Math.random()-0.5) * 28;
      active.push({el, x: startX, y: startY, vx, vy, rot, type: name, cut: false});
    }catch(e){ dbg('spawnOne error: '+e,'error'); }
  }

  // ===== Main animation loop =====
  let last = performance.now();
  function step(now){
    const dt = Math.min(40, now - last) / 16.666; last = now;
    const floor = areaH - 36;
    for(let i=active.length-1;i>=0;i--){
      const f = active[i];
      f.vy -= GRAVITY * dt;
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.rot += f.vx * 0.7 * dt;
      if(f.y > floor){ f.y = floor; f.vy = -Math.abs(f.vy) * 0.45; }
      try{ f.el.style.transform = `translate3d(${f.x}px, ${-f.y}px, 0) rotate(${f.rot}deg)`; }catch(e){}
      if(f.x < -300 || f.x > areaW + 300 || f.y < -600){ try{ releaseFruit(f.el); }catch(e){} active.splice(i,1); }
    }
    try{ drawSplats(); drawBlade(); }catch(e){}
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // blade drawing & pointer handling
  let bladePoints = [];
  function addBladePoint(clientX, clientY){ const rect = gameArea.getBoundingClientRect(); bladePoints.push({x: clientX - rect.left, y: clientY - rect.top, t: Date.now()}); if(bladePoints.length > MAX_BLADE) bladePoints.shift(); }
  function drawBlade(){ if(!bladeCtx) return; bladeCtx.clearRect(0,0, bladeCanvas.width, bladeCanvas.height); if(bladePoints.length < 2) return; bladeCtx.lineJoin='round'; bladeCtx.lineCap='round'; for(let i=0;i<bladePoints.length-1;i++){ const a = bladePoints[i], b = bladePoints[i+1]; const age = Date.now() - a.t; const alpha = Math.max(0, 1 - age/380); bladeCtx.strokeStyle = `rgba(34,197,94,${0.9*alpha})`; bladeCtx.lineWidth = 8*alpha + 2; bladeCtx.beginPath(); bladeCtx.moveTo(a.x,a.y); bladeCtx.lineTo(b.x,b.y); bladeCtx.stroke(); } }

  let isDown=false, lastPtr=0, pointerHistory=[];
  function onPointerDown(e){ isDown=true; pointerHistory=[]; addBladePoint(e.clientX, e.clientY); e.preventDefault && e.preventDefault(); }
  function onPointerMove(e){
    if(!isDown) return;
    const now = Date.now(); if(now - lastPtr < PTR_THROTTLE) return; lastPtr = now;
    addBladePoint(e.clientX, e.clientY);
    pointerHistory.push({x: e.clientX, y: e.clientY});
    if(pointerHistory.length > 18) pointerHistory.shift();
    if(pointerHistory.length >= 2){
      const p1 = pointerHistory[pointerHistory.length-2]; const p2 = pointerHistory[pointerHistory.length-1];
      const snap = Array.from(active);
      for(const f of snap){
        try{
          const r = f.el.getBoundingClientRect();
          if(lineIntersectsRect(p1, p2, r)) handleSlice(f, p1, p2);
        }catch(e){}
      }
    }
  }
  function onPointerUp(){ isDown=false; pointerHistory=[]; bladePoints=[]; drawBlade(); }
  window.addEventListener('pointerdown', onPointerDown, {passive:false});
  window.addEventListener('pointermove', onPointerMove, {passive:false});
  window.addEventListener('pointerup', onPointerUp);
  window.addEventListener('pointercancel', onPointerUp);

  function lineIntersectsRect(p1, p2, rect){
    if((p1.x < rect.left && p2.x < rect.left) || (p1.x > rect.right && p2.x > rect.right) ||
       (p1.y < rect.top && p2.y < rect.top) || (p1.y > rect.bottom && p2.y > rect.bottom)) return false;
    return true;
  }

  function juiceColorFor(name){
    name = (name||'').toLowerCase();
    if(name.includes('apple')) return {r:220,g:50,b:60};
    if(name.includes('banana')) return {r:240,g:210,b:60};
    if(name.includes('orange')) return {r:245,g:140,b:40};
    if(name.includes('strawberry')) return {r:230,g:80,b:90};
    if(name.includes('watermelon')) return {r:250,g:100,b:120};
    if(name.includes('mango')) return {r:255,g:160,b:40};
    if(name.includes('papaya')) return {r:250,g:140,b:60};
    if(name.includes('pineapple')) return {r:245,g:180,b:70};
    if(name.includes('pomegranate')) return {r:190,g:20,b:30};
    return {r:240,g:120,b:100};
  }

  // handleSlice with splat + combo + halves
  function handleSlice(f, p1, p2){
    try{
      if(!f || f.cut) return;
      f.cut = true;
      const type = f.type || (f.el && f.el.dataset && f.el.dataset.type);
      if(type === BOMB){
        lives = Math.max(0, lives - 1);
        dbg('Bomb sliced. lives=' + lives, 'error');
        removeFruit(f); updateHUD(); saveStateDebounced();
        if(lives <= 0) endGame();
        return;
      }
      const rect = f.el.getBoundingClientRect();
      const cx = rect.left + rect.width/2 - gameArea.getBoundingClientRect().left;
      const cy = rect.top + rect.height/2 - gameArea.getBoundingClientRect().top;
      const color = juiceColorFor(type);
      addSplat(cx + (Math.random()-0.5)*18, cy + (Math.random()-0.5)*12, color, 20 + Math.random()*14, 1);
      addSplat(cx + (Math.random()-0.5)*30, cy + (Math.random()-0.5)*20, color, 8 + Math.random()*10, 0.9);

      // small juice DOM particles
      const smallCount = 5;
      for(let i=0;i<smallCount;i++){
        const j = acquireJuice();
        const size = 5 + Math.random()*7;
        j.style.width = size + 'px'; j.style.height = size + 'px';
        j.style.left = (cx + (Math.random()-0.5)*12) + 'px';
        j.style.top = (cy + (Math.random()-0.5)*12) + 'px';
        j.style.background = `rgba(${color.r},${color.g},${color.b},${0.9 - Math.random()*0.2})`;
        gameArea.appendChild(j);
        (function(juiceEl){
          const sx = parseFloat(juiceEl.style.left), sy = parseFloat(juiceEl.style.top);
          const vx = (Math.random()-0.5) * 6, vy = - (2 + Math.random()*6);
          const start = performance.now();
          function anim(now){
            const t = (now - start)/1000;
            const x = sx + vx * t * 60;
            const y = sy + vy * t * 60 + 0.5 * GRAVITY * t * t * 60;
            juiceEl.style.left = x + 'px'; juiceEl.style.top = y + 'px';
            juiceEl.style.opacity = String(Math.max(0, 1 - t * 1.4));
            if(t < 0.9) requestAnimationFrame(anim); else releaseJuice(juiceEl);
          }
          requestAnimationFrame(anim);
        })(j);
      }

      // combo scoring
      const now = Date.now(); lastSlices.push(now); lastSlices = lastSlices.filter(ts => now - ts <= COMBO_WINDOW_MS);
      const count = lastSlices.length; const idx = Math.min(Math.max(0, count-1), COMBO_MULT.length - 1); const mult = COMBO_MULT[idx] || 1;
      const base = 10; const awarded = Math.round(base * mult);
      score += awarded; coins += Math.round(2 * mult);
      coinPop && (coinPop.textContent = '+' + Math.round(2 * mult), coinPop.style.display = 'block', setTimeout(()=> coinPop.style.display = 'none', 700));
      if(count > 1){
        const comboBadge = document.getElementById('comboBadge');
        comboBadge && (comboBadge.textContent = `COMBO x${count}!`, comboBadge.style.display = 'block', comboBadge.style.transform = 'translateX(-50%) scale(1.12)', comboBadge.style.opacity = '1', setTimeout(()=>{ comboBadge.style.transition = 'transform .6s, opacity .6s'; comboBadge.style.transform = 'translateX(-50%) scale(.92)'; comboBadge.style.opacity = '0'; setTimeout(()=>{ comboBadge.style.display = 'none'; comboBadge.style.transition=''; comboBadge.style.transform='translateX(-50%) scale(0.9)'; }, 620); }, 330));
      }

      updateHUD(); saveStateDebounced();

      // halves
      removeFruit(f); createHalves(rect, type);
    }catch(err){ dbg('handleSlice error: '+err, 'error'); }
  }

  function removeFruit(f){ for(let i=active.length-1;i>=0;i--) if(active[i]===f){ try{ if(active[i].el.parentNode) active[i].el.parentNode.removeChild(active[i].el); }catch(e){} active.splice(i,1); break; } }

  function createHalves(rect, type){
    try{
      const centerX = rect.left + rect.width/2 - gameArea.getBoundingClientRect().left;
      const centerY = rect.top + rect.height/2 - gameArea.getBoundingClientRect().top;
      const wrapper = document.createElement('div');
      wrapper.style.position='absolute'; wrapper.style.left = (centerX - rect.width/2) + 'px'; wrapper.style.bottom = (-(centerY - rect.height/2)) + 'px';
      wrapper.style.width = rect.width + 'px'; wrapper.style.height = rect.height + 'px'; wrapper.style.pointerEvents='none'; wrapper.style.zIndex=980;

      const left = document.createElement('div'); left.style.position='absolute'; left.style.left='0'; left.style.top='0'; left.style.width='50%'; left.style.height='100%'; left.style.overflow='hidden';
      const li = document.createElement('img'); li.src = CACHE[type] ? CACHE[type].src : 'images/' + type; li.style.position='absolute'; li.style.width='200%'; li.style.height='100%';
