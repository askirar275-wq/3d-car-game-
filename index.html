<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruit Cut + Console</title>
<style>
:root{--ui:#f4f7fb;--panel:#efe9e1;--btn:#111;--muted:#666}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;background:var(--ui);font-family:Inter,system-ui,Roboto,Arial,sans-serif;color:#111}
.container{max-width:820px;margin:0 auto;padding:12px}
h1{margin:6px 0 8px;text-align:center}
.hud{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
.stat{background:#fff;padding:8px 12px;border-radius:12px;box-shadow:0 8px 22px rgba(0,0,0,0.06);font-weight:700}
#gameWrapper{position:relative;border-radius:14px;overflow:hidden;background:linear-gradient(180deg,#bfe9ff,#f6f7fb);height:56vh;min-height:380px}
#sky{position:absolute;inset:0;z-index:1}
#gameArea{position:absolute;inset:0;z-index:2;touch-action:none}
canvas#bladeCanvas, canvas#particles{position:absolute;inset:0;z-index:6;pointer-events:none}
.fruit, .half{position:absolute;transform:translate(-50%,-50%);user-select:none;pointer-events:none;z-index:5}
#bigStart{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:10;background:var(--btn);color:#fff;padding:14px 18px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 12px 34px rgba(0,0,0,0.25)}
.controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;padding:12px;margin-top:8px}
.btn{background:#fff;border:0;padding:10px 14px;border-radius:12px;cursor:pointer;box-shadow:0 8px 20px rgba(2,6,23,0.06);font-weight:700}
.btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06)}
.consoleBox{position:absolute;right:8px;top:8px;background:rgba(0,0,0,0.72);color:#fff;padding:8px;border-radius:8px;z-index:1200;max-height:46%;overflow:auto;font-family:monospace;font-size:12px;display:none}
.hidden{display:none}
.card{background:#fff;padding:14px;border-radius:10px;box-shadow:0 12px 36px rgba(2,6,23,0.12)}
#gameOver{position:absolute;inset:0;z-index:1400;display:none;align-items:center;justify-content:center}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 14px;border-radius:999px;z-index:1600;display:none}
@media (min-width:900px){#gameWrapper{height:560px}}
</style>
</head>
<body>
<div class="container">
  <h1>üçâ Fruit Cut ‚Äî Fixed Start + Console</h1>
  <div class="hud">
    <div class="stat">Score: <span id="score">0</span></div>
    <div class="stat">Lives: <span id="lives">3</span></div>
    <div class="stat">Coins: <span id="coins">0</span></div>
    <div class="stat">Level: <span id="level">1</span></div>
  </div>

  <div id="gameWrapper">
    <div id="sky"></div>
    <div id="gameArea" aria-label="game area"></div>
    <canvas id="bladeCanvas"></canvas>
    <canvas id="particles"></canvas>

    <div id="bigStart">START</div>

    <div id="gameOver">
      <div class="card" style="text-align:center">
        <h2>Game Over</h2>
        <p>Score: <span id="goScore">0</span></p>
        <p>Best: <span id="goBest">0</span></p>
        <div style="margin-top:12px"><button id="goRestart" class="btn">Play Again</button></div>
      </div>
    </div>

    <div id="consoleBox" class="consoleBox"></div>
  </div>

  <div class="controls">
    <button id="startBtn" class="btn">Start</button>
    <button id="pauseBtn" class="btn">Pause</button>
    <button id="restartBtn" class="btn">Restart</button>
    <button id="toggleConsole" class="btn">Toggle Console</button>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
/* Robust single-file game ‚Äî fixed start and console toggling */
(() => {
  // config - image folder and names
  const IMG_PATH = 'images/'; // keep your images here
  const FRUITS = ['apple.png','banana.png','cantaloupe.png','guava.png','mango.png','orange.png','papaya.png','pear.png','pineapple.png','plum.png','pomegranate.png','strawberry.png','watermelon.png'];
  const BOMB = 'bomb.png';

  // DOM
  const area = document.getElementById('gameArea');
  const bladeCanvas = document.getElementById('bladeCanvas');
  const particlesCanvas = document.getElementById('particles');
  const bigStart = document.getElementById('bigStart');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const toggleConsole = document.getElementById('toggleConsole');
  const consoleBox = document.getElementById('consoleBox');
  const gameOver = document.getElementById('gameOver');
  const goRestart = document.getElementById('goRestart');
  const goScore = document.getElementById('goScore');
  const goBest = document.getElementById('goBest');
  const toast = document.getElementById('toast');

  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const coinsEl = document.getElementById('coins');
  const levelEl = document.getElementById('level');

  // canvas contexts
  const bctx = bladeCanvas.getContext('2d');
  const pctx = particlesCanvas.getContext('2d');

  // state
  let running = false, paused = false;
  let score = 0, lives = 3, coins = 0, level = 1;
  let spawnInterval = 900, spawnTimer = null;
  let fruits = [], particles = [], bladePoints = [];
  let imageCache = {};
  let consoleVisible = false;

  function log(...args){
    const s = `[FruitCut] ${args.join(' ')}`;
    console.log(s);
    const d = document.createElement('div'); d.textContent = s;
    consoleBox.prepend(d); // newest on top
  }

  function showToast(msg, t=1200){ toast.textContent = msg; toast.style.display = 'block'; setTimeout(()=> toast.style.display = 'none', t); }

  // resize canvases
  function resize(){
    const r = area.getBoundingClientRect();
    bladeCanvas.width = Math.max(1, Math.floor(r.width));
    bladeCanvas.height = Math.max(1, Math.floor(r.height));
    particlesCanvas.width = bladeCanvas.width;
    particlesCanvas.height = bladeCanvas.height;
  }
  window.addEventListener('resize', resize);

  // preload images but allow start even if some fail
  const ALL = FRUITS.concat([BOMB]);
  function preloadAll(timeout = 2500){
    return new Promise((resolve) => {
      let loaded = 0, done = false;
      ALL.forEach(name=>{
        const img = new Image();
        img.onload = ()=>{ imageCache[name] = img; loaded++; log('loaded', name); if(loaded === ALL.length && !done){ done = true; resolve(true);} };
        img.onerror = ()=>{ log('failed:', name); loaded++; if(loaded === ALL.length && !done){ done = true; resolve(false);} };
        img.src = IMG_PATH + name;
      });
      // safety timeout
      setTimeout(()=>{ if(!done){ done = true; log('preload timed out ‚Äî continuing'); resolve(false); } }, timeout);
    });
  }

  // spawn fruit object
  function spawn(){
    if(!running || paused) return;
    const isBomb = Math.random() < 0.08;
    const name = isBomb ? BOMB : FRUITS[Math.floor(Math.random()*FRUITS.length)];
    const imgSrc = (imageCache[name] && imageCache[name].src) ? imageCache[name].src : (IMG_PATH + name);
    const el = document.createElement('img');
    el.src = imgSrc;
    el.className = 'fruit';
    // size smaller for mobile but visible
    const size = Math.max(64, Math.min(140, Math.floor(area.clientWidth * 0.16)));
    el.style.width = size + 'px';
    const x = rand(60, area.clientWidth - 60);
    const startY = area.clientHeight + 40;
    el.style.left = x + 'px';
    el.style.top = startY + 'px';
    el.style.transform = 'translate(-50%,-50%) rotate(' + rand(-30,30) + 'deg)';
    area.appendChild(el);

    const obj = { name, el, x, y: startY, vx: rand(-2,2), vy: -rand(12,16), rot: rand(-30,30), sliced:false, isBomb };
    fruits.push(obj);
    log('spawned', name, imageCache[name] ? '(cached)' : '(fallback)');
  }

  // random util
  function rand(a,b){ return Math.random()*(b-a)+a; }

  // update physics & remove offscreen
  function update(){
    for(let i = fruits.length -1; i >= 0; i--){
      const f = fruits[i];
      f.vy += 0.36; // gravity
      f.x += f.vx; f.y += f.vy; f.rot += f.vx*1.5;
      if(f.el){
        f.el.style.left = f.x + 'px';
        f.el.style.top = f.y + 'px';
        f.el.style.transform = 'translate(-50%,-50%) rotate(' + f.rot + 'deg)';
      }
      if(f.y > area.clientHeight + 90){
        if(!f.sliced && !f.isBomb){
          // missed fruit -> user said "no penalty" so do nothing
        }
        if(f.el) f.el.remove();
        fruits.splice(i,1);
      }
    }
  }

  // create halves effect when fruit sliced
  function makeHalves(f){
    const w = parseInt(f.el.style.width) || 80;
    const left = document.createElement('img');
    const right = document.createElement('img');
    left.className = right.className = 'half';
    left.src = right.src = f.el.src;
    left.style.width = right.style.width = w + 'px';
    left.style.left = f.x + 'px'; left.style.top = f.y + 'px';
    right.style.left = f.x + 'px'; right.style.top = f.y + 'px';
    area.appendChild(left); area.appendChild(right);
    left.style.clipPath = 'polygon(0 0,50% 0,50% 100%,0 100%)';
    right.style.clipPath = 'polygon(50% 0,100% 0,100% 100%,50% 100%)';
    // animate separation
    const start = Date.now();
    const dur = 700;
    (function anim(){
      const t = (Date.now() - start)/dur;
      if(t >= 1){ left.remove(); right.remove(); return; }
      left.style.left = (f.x - 14*t*6) + 'px';
      left.style.top = (f.y - 30*t + t*10) + 'px';
      left.style.transform = 'translate(-50%,-50%) rotate(' + (f.rot - 30*t) + 'deg)';
      right.style.left = (f.x + 14*t*6) + 'px';
      right.style.top = (f.y - 30*t + t*10) + 'px';
      right.style.transform = 'translate(-50%,-50%) rotate(' + (f.rot + 30*t) + 'deg)';
      requestAnimationFrame(anim);
    })();
  }

  // particles for fun
  function spawnParticles(x,y,color){
    for(let i=0;i<12;i++){
      particles.push({x,y,vx:rand(-3,3),vy:rand(-6,-1),color,created:Date.now(),life:rand(500,900)});
    }
  }

  // drawing blade & particles
  function draw(){
    bctx.clearRect(0,0,bladeCanvas.width, bladeCanvas.height);
    if(bladePoints.length > 1){
      bctx.lineJoin='round'; bctx.lineCap='round';
      bctx.strokeStyle = '#22c55e';
      for(let i=0;i<bladePoints.length-1;i++){
        const a = bladePoints[i], b = bladePoints[i+1];
        const alpha = Math.max(0, 1 - (Date.now() - a.t)/350);
        bctx.globalAlpha = alpha;
        bctx.lineWidth = 14 * alpha;
        bctx.beginPath(); bctx.moveTo(a.x,a.y); bctx.lineTo(b.x,b.y); bctx.stroke();
      }
      bctx.globalAlpha = 1;
    }

    // particles
    pctx.clearRect(0,0,particlesCanvas.width, particlesCanvas.height);
    const now = Date.now();
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i]; const age = now - p.created;
      if(age > p.life){ particles.splice(i,1); continue; }
      p.vy += 0.12; p.x += p.vx; p.y += p.vy;
      const a = 1 - age/p.life;
      pctx.globalAlpha = a;
      pctx.fillStyle = p.color;
      pctx.beginPath(); pctx.arc(p.x, p.y, 3.2, 0, Math.PI*2); pctx.fill();
    }
    pctx.globalAlpha = 1;
  }

  // detection: pointer intersects fruit rect
  function rectIntersectsPoint(rect, px, py){
    return px >= rect.left && px <= rect.right && py >= rect.top && py <= rect.bottom;
  }

  // pointer handling
  function onPointerMove(e){
    if(!running || paused) return;
    const r = area.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    bladePoints.push({x,y,t:Date.now()});
    if(bladePoints.length > 26) bladePoints.shift();

    // check fruits
    for(let i = fruits.length -1; i >= 0; i--){
      const f = fruits[i];
      if(f.sliced) continue;
      const rect = f.el.getBoundingClientRect();
      if(rectIntersectsPoint(rect, e.clientX, e.clientY)){
        f.sliced = true;
        if(f.isBomb){
          lives = Math.max(0, lives - 1);
          spawnParticles(f.x, f.y, '#ff4d4d');
          log('Bomb sliced. lives=' + lives);
          if(lives <= 0){ endGame(); }
        } else {
          score += 10; coins += 1;
          spawnParticles(f.x, f.y, '#ffd54d');
          makeHalves(f);
          log('Fruit sliced: ' + f.name);
        }
        updateHUD();
        if(f.el) f.el.remove();
        fruits.splice(i,1);
      }
    }
  }

  // update physics loop
  function physicsTick(){
    if(running && !paused){
      update();
      draw();
    }
    requestAnimationFrame(physicsTick);
  }

  // spawn timer management
  function startSpawning(){
    if(spawnTimer) clearInterval(spawnTimer);
    spawnTimer = setInterval(()=>spawn(), spawnInterval);
  }
  function stopSpawning(){ if(spawnTimer) clearInterval(spawnTimer); spawnTimer = null; }

  // start / pause / restart / end
  function startGame(auto=false){
    // hide game over
    gameOver.style.display = 'none';
    if(running) return;
    running = true; paused = false;
    if(!auto){ score = 0; lives = 3; coins = 0; level = 1; updateHUD(); }
    bigStart.style.display = 'none';
    startSpawning();
    log('Game started');
  }
  function pauseGame(){
    paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  }
  function restartGame(){
    stopSpawning();
    fruits.forEach(f=>f.el && f.el.remove()); fruits = [];
    particles = []; bladePoints = [];
    running = false; paused = false;
    bigStart.style.display = 'block'; gameOver.style.display = 'none';
    startGame(false);
  }
  function endGame(){
    running = false; stopSpawning();
    goScore.textContent = score;
    const best = Math.max(Number(localStorage.getItem('fc_best')||0), score);
    localStorage.setItem('fc_best', best);
    goBest.textContent = best;
    gameOver.style.display = 'flex';
    bigStart.style.display = 'block';
    log('Game over. score=' + score);
  }

  // hud update
  function updateHUD(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    coinsEl.textContent = coins;
    levelEl.textContent = level;
  }

  // utilities
  function toggleConsoleUI(){
    consoleVisible = !consoleVisible;
    consoleBox.style.display = consoleVisible ? 'block' : 'none';
  }

  // start bindings
  startBtn.addEventListener('click', ()=> startGame());
  bigStart.addEventListener('click', ()=> startGame());
  pauseBtn.addEventListener('click', ()=> pauseGame());
  restartBtn.addEventListener('click', ()=> restartGame());
  toggleConsole.addEventListener('click', ()=> toggleConsoleUI());
  goRestart.addEventListener('click', ()=> { gameOver.style.display='none'; restartGame(); });

  // pointer listeners on window to capture swipes
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerdown', onPointerMove);
  window.addEventListener('pointerup', ()=> { bladePoints = []; });

  // resizing and initial start logic
  function init(){
    resize();
    physicsTick();
    // preload images; start after a short timeout even if preload is slow
    preloadAll(2200).then(()=>{
      log('preload finished');
      // small delay then auto-start
      setTimeout(()=>{ if(!running) { log('auto-start fallback'); startGame(true); } }, 300);
    });
  }

  // helper: safely set sizes on load
  window.addEventListener('load', init);

  // expose for debug
  window.FruitCut = { start:startGame, pause:pauseGame, restart:restartGame };

  // initial HUD
  updateHUD();

})();
</script>
</body>
  </html>
