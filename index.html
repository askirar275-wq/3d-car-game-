<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruit Cut ‚Äî Loading Emoji Slice</title>
<style>
  :root{
    --bg:#f4f7fb; --card:#f0ece7; --accent:#22c55e; --btn:#111;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:var(--bg);color:#111}
  .container{max-width:520px;margin:8px auto;padding:8px}
  h1{font-size:26px;margin:4px 0 10px}
  .hud{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:8px;align-items:center}
  .stat{background:#fff;padding:8px 12px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.04)}
  #gameWrapper{position:relative;height:66vh;min-height:420px;border-radius:12px;overflow:hidden;border:1px solid rgba(0,0,0,0.06);background:linear-gradient(180deg,#e6f7ff 0%, #f7f2e8 100%);display:flex;align-items:center;justify-content:center}
  #gameArea{position:absolute;inset:0;touch-action:none}
  canvas#blade{position:absolute;inset:0;z-index:150;pointer-events:none}
  #loadingOverlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:200;background:rgba(255,255,255,0.88);flex-direction:column;gap:12px}
  .progress{width:70%;max-width:380px;height:12px;border-radius:999px;background:#eee;overflow:hidden}
  .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#06b6d4)}
  .progressText{font-size:14px;color:#333}
  #emojiStage{position:absolute;inset:0;z-index:210;pointer-events:auto}
  .emoji{position:absolute;font-size:74px;user-select:none;touch-action:none;cursor:default;pointer-events:auto;transform-origin:center;will-change:transform,opacity}
  .btnRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  button{padding:9px 14px;border-radius:12px;border:0;background:var(--btn);color:#fff;cursor:pointer;font-weight:700}
  .ghost{background:#fff;color:#111;border:1px solid #eee;box-shadow:none}
  #bigStart{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:120;background:rgba(0,0,0,0.9);color:#fff;padding:14px 22px;border-radius:12px;font-size:18px;cursor:pointer;display:none}
  .scorePop{position:absolute;right:12px;top:12px;background:#fff;padding:6px 10px;border-radius:8px;z-index:500;display:none;box-shadow:0 10px 30px rgba(2,6,23,0.08)}
  /* small screen tweaks */
  @media (max-width:420px){ .emoji{font-size:56px} #gameWrapper{height:62vh} }
  /* cutting halves simple style (for image game later) */
  .half{position:absolute;pointer-events:none;will-change:transform,opacity}
</style>
</head>
<body>
<div class="container">
  <h1>üçâ Fruit Cut ‚Äî Loading Emoji Slice</h1>

  <div class="hud">
    <div class="stat">Score: <strong id="score">0</strong></div>
    <div class="stat">Lives: <strong id="lives">3</strong></div>
    <div class="stat">Coins: <strong id="coins">0</strong></div>
    <div style="flex:1"></div>
    <div class="stat">Level: <strong id="level">1</strong></div>
  </div>

  <div id="gameWrapper">
    <div id="gameArea" aria-label="Game area"></div>
    <canvas id="blade"></canvas>

    <!-- Loading overlay: shows until images preloaded -->
    <div id="loadingOverlay" aria-hidden="false">
      <div id="emojiStage" aria-hidden="false"></div>
      <div class="progress" aria-hidden="true"><div class="bar" id="bar"></div></div>
      <div class="progressText" id="progressText">Loading images... 0 / 0</div>
    </div>

    <!-- Big start: appears after preload -->
    <div id="bigStart">START</div>

    <div class="scorePop" id="scorePop">+0</div>
  </div>

  <div class="btnRow">
    <button id="startBtn" class="ghost">Start</button>
    <button id="pauseBtn" class="ghost" disabled>Pause</button>
    <button id="restartBtn" class="ghost">Restart</button>
    <button id="shopBtn" class="ghost">Shop</button>
  </div>
</div>

<script>
/*
 Single-file final:
 - Preloads images from IMAGES array (relative path 'images/')
 - While preload runs: emojiStage spawns emoji which user can slice
 - Slicing emoji creates a split animation + increases score
 - When preload done: loadingOverlay hides, bigStart shows
 - Blade trail + pointer handling implemented
 - Adjust IMAGES array to match your /images/ filenames
*/

/* ===== CONFIG ===== */
const IMG_PATH = 'images/'; // folder where your fruit PNGs live (relative)
const IMAGES = [
  'apple.png','banana.png','orange.png','strawberry.png','watermelon.png',
  'mango.png','papaya.png','pineapple.png','pomegranate.png','pear.png',
  'plum.png','guava.png','cantaloupe.png','bomb.png'
];
const EMOJI_CHOICE = ['üçâ','üçé','üçä','üçå','üçç','ü•≠','üçì','üçê']; // used while loading
const EMOJI_SPAWN_INTERVAL = 700; // ms spawn emoji while loading
const EMOJI_SIZE = 72; // px (font-size)
const MAX_EMOJI = 10;

/* ===== STATE ===== */
let loadedImages = {}; // filename -> Image element
let preloadCount = 0;
let score = 0, lives = 3, coins = 0, level = 1;
let running = false;

/* ===== DOM ===== */
const gameArea = document.getElementById('gameArea');
const loadingOverlay = document.getElementById('loadingOverlay');
const emojiStage = document.getElementById('emojiStage');
const bar = document.getElementById('bar');
const progressText = document.getElementById('progressText');
const bigStart = document.getElementById('bigStart');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const coinsEl = document.getElementById('coins');
const levelEl = document.getElementById('level');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');
const shopBtn = document.getElementById('shopBtn');
const scorePop = document.getElementById('scorePop');

/* ===== BLADE CANVAS ===== */
const blade = document.getElementById('blade');
const bctx = blade.getContext('2d');
let bladePoints = [];
const MAX_POINTS = 26;
function resizeCanvas(){
  const r = gameArea.getBoundingClientRect();
  blade.width = Math.max(1, Math.floor(r.width));
  blade.height = Math.max(1, Math.floor(r.height));
  blade.style.left = r.left + 'px';
  blade.style.top = r.top + 'px';
}
window.addEventListener('resize', resizeCanvas);
setTimeout(resizeCanvas,50);

/* draw blade */
function addBladePoint(x,y){
  const r = gameArea.getBoundingClientRect();
  bladePoints.push({x:x - r.left, y:y - r.top, t:Date.now()});
  if (bladePoints.length > MAX_POINTS) bladePoints.shift();
}
function drawBlade(){
  bctx.clearRect(0,0,blade.width, blade.height);
  if (bladePoints.length < 2){ requestAnimationFrame(drawBlade); return; }
  bctx.lineJoin = 'round'; bctx.lineCap = 'round';
  for (let i=0;i<bladePoints.length-1;i++){
    const p1 = bladePoints[i], p2 = bladePoints[i+1];
    const age = Date.now() - p1.t;
    const alpha = Math.max(0, 1 - age/350);
    bctx.strokeStyle = `rgba(34,197,94,${0.92*alpha})`;
    bctx.lineWidth = 18 * alpha;
    bctx.beginPath(); bctx.moveTo(p1.x,p1.y); bctx.lineTo(p2.x,p2.y); bctx.stroke();
  }
  bladePoints = bladePoints.filter(p => (Date.now() - p.t) < 450);
  requestAnimationFrame(drawBlade);
}
drawBlade();

/* pointer handling */
let pointerDown = false;
window.addEventListener('pointerdown', e=>{ pointerDown = true; addBladePoint(e.clientX,e.clientY); });
window.addEventListener('pointermove', e=>{ if (pointerDown) addBladePoint(e.clientX,e.clientY); checkHits(e.clientX,e.clientY); });
window.addEventListener('pointerup', e=>{ pointerDown = false; bladePoints = []; });
window.addEventListener('pointercancel', ()=>{ pointerDown = false; bladePoints = []; });

/* ===== LOADING / EMOJI SPAWN WHILE LOADING ===== */
let emojiTimer = null;
function spawnEmoji(){
  if (!loadingOverlay || !emojiStage) return;
  if (emojiStage.children.length >= MAX_EMOJI) return;
  const e = document.createElement('div');
  e.className = 'emoji';
  e.style.fontSize = EMOJI_SIZE + 'px';
  // random emoji
  e.textContent = EMOJI_CHOICE[Math.floor(Math.random()*EMOJI_CHOICE.length)];
  // random horizontal position and start near bottom so it floats up
  const rw = gameArea.getBoundingClientRect().width;
  const x = Math.max(8, Math.random()*(rw - 60));
  const y = gameArea.getBoundingClientRect().height - 90;
  e.style.left = x + 'px';
  e.style.top = y + 'px';
  // add gentle up floating animation using JS
  emojiStage.appendChild(e);
  // animate: float up and wobble
  const start = Date.now();
  const duration = 4200 + Math.random()*1800;
  function tick(){
    const t = (Date.now()-start)/duration;
    if (t>=1){ e.remove(); return; }
    // easing
    const yy = y - (Math.sin(t*Math.PI)*0.6 + t*0.8) * (gameArea.getBoundingClientRect().height*0.6);
    const angle = Math.sin(t*10 + Math.random()) * 18;
    e.style.top = yy + 'px';
    e.style.transform = `rotate(${angle}deg)`;
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

/* detect hits on emoji stage */
function checkHits(clientX, clientY){
  if (!pointerDown) return;
  // convert to stage coordinates
  const r = emojiStage.getBoundingClientRect();
  const x = clientX - r.left, y = clientY - r.top;
  // query emoji elements under the pointer
  const list = Array.from(emojiStage.children);
  for (const el of list){
    const rect = el.getBoundingClientRect();
    if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom){
      // slice it
      sliceEmoji(el);
    }
  }
}

/* slice animation for emoji element */
function sliceEmoji(el){
  if (!el || el.dataset.sliced) return;
  el.dataset.sliced = '1';
  const rect = el.getBoundingClientRect();
  // two clones representing halves
  const halfA = el.cloneNode(true);
  const halfB = el.cloneNode(true);
  halfA.className = 'half';
  halfB.className = 'half';
  document.body.appendChild(halfA);
  document.body.appendChild(halfB);
  // position halves at same spot
  halfA.style.left = rect.left + 'px'; halfA.style.top = rect.top + 'px';
  halfB.style.left = rect.left + 'px'; halfB.style.top = rect.top + 'px';
  halfA.style.transformOrigin = 'left center'; halfB.style.transformOrigin = 'right center';
  // hide original
  el.style.transition = 'opacity .12s'; el.style.opacity = 0;
  // animate split
  requestAnimationFrame(()=>{
    halfA.style.transition = 'transform 820ms cubic-bezier(.2,.9,.3,1), opacity 820ms';
    halfB.style.transition = 'transform 820ms cubic-bezier(.2,.9,.3,1), opacity 820ms';
    halfA.style.transform = `translate(${-40 - (Math.random()*30)}px, ${40 + Math.random()*40}px) rotate(${ -25 - Math.random()*40 }deg)`;
    halfB.style.transform = `translate(${40 + (Math.random()*30)}px, ${40 + Math.random()*40}px) rotate(${ 25 + Math.random()*40 }deg)`;
    halfA.style.opacity = 0; halfB.style.opacity = 0;
  });
  // cleanup
  setTimeout(()=>{ try{ el.remove(); }catch(e){} try{ halfA.remove(); halfB.remove(); }catch(e){} },900);
  // score pop
  showScorePop('+1', rect.left + rect.width/2, rect.top + rect.height/2);
  score += 1; scoreEl.textContent = score;
}

/* small floating score popup */
function showScorePop(text, x, y){
  scorePop.textContent = text;
  scorePop.style.left = (x + 6) + 'px';
  scorePop.style.top = (y - 8) + 'px';
  scorePop.style.display = 'block'; scorePop.style.opacity = 1;
  scorePop.style.transform = 'translateY(0)';
  setTimeout(()=>{ scorePop.style.transition = 'all 720ms ease'; scorePop.style.opacity = 0; scorePop.style.transform = 'translateY(-20px)'; },80);
  setTimeout(()=>{ scorePop.style.display = 'none'; scorePop.style.transition = ''; },900);
}

/* ===== PRELOAD IMAGES (with robust fallback) ===== */
function preloadAll(list, onProgress){
  return new Promise(resolve=>{
    let total = list.length, done = 0;
    // attempt to load from IMG_PATH; if any fail, we still continue
    function tryLoad(name){
      const img = new Image();
      img.onload = ()=>{ loadedImages[name] = img; done++; onProgress(done,total,name,true); if (done===total) resolve(); };
      img.onerror = ()=>{ console.warn('[preload] failed', name); done++; onProgress(done,total,name,false); if (done===total) resolve(); };
      img.src = IMG_PATH + name;
      // add cache-busting small delay if browser blocks; but keep src straightforward
    }
    // start all loads
    for (const nm of list) tryLoad(nm);
  });
}

/* progress callback */
function onPreloadProgress(done,total,name,ok){
  progressText.textContent = `Loading images... ${done} / ${total} ${ok?('(ok)'):('(failed)')}`;
  bar.style.width = `${Math.round((done/total)*100)}%`;
}

/* start emoji spawning and allow slicing while loading */
function startLoadingPhase(){
  // spawn emoji periodically
  emojiTimer = setInterval(spawnEmoji, EMOJI_SPAWN_INTERVAL);
  // also spawn some immediately
  for (let i=0;i<3;i++) setTimeout(spawnEmoji, i*220);
}

/* stop loading phase */
function stopLoadingPhase(){
  clearInterval(emojiTimer); emojiTimer = null;
  // remove remaining emoji
  emojiStage.querySelectorAll('.emoji').forEach(e=>e.remove());
}

/* when preload finished */
function onPreloadDone(){
  stopLoadingPhase();
  // hide overlay and show start
  loadingOverlay.style.display = 'none';
  bigStart.style.display = 'block';
  // small auto-start optional: we won't auto-start; show bigStart
}

/* ===== HITCH: allow slicing emojis during loading (pointer checks already done) ===== */

/* ===== UI wiring ===== */
bigStart.addEventListener('click', ()=>{ startGame(); bigStart.style.display = 'none'; });
startBtn.addEventListener('click', ()=>{ startGame(); });
pauseBtn.addEventListener('click', ()=>{ pauseGame(); });
restartBtn.addEventListener('click', ()=>{ restartGame(); });
shopBtn.addEventListener('click', ()=>{ alert('Shop placeholder ‚Äî implement later'); });

/* game loop placeholders & spawn real fruit later */
let spawnIntervalId = null;
function startGame(){
  if (running) return;
  running = true;
  pauseBtn.disabled = false;
  // start spawn loop (for real game images)
  spawnIntervalId = setInterval(()=>spawnFruitFromImages(), 900);
  console.log('[Game] started');
}
function pauseGame(){ if (!running) return; running = false; clearInterval(spawnIntervalId); spawnIntervalId = null; pauseBtn.disabled = true; console.log('[Game] paused'); }
function restartGame(){ stopAll(); score = 0; lives = 3; coins = 0; updateHUD(); startGame(); console.log('[Game] restarted'); }
function stopAll(){ running = false; clearInterval(spawnIntervalId); spawnIntervalId = null; }

/* spawn placeholder fruits once images ready (we will create real <img> nodes) */
function spawnFruitFromImages(){
  if (!running) return;
  // pick a random image that loaded
  const names = Object.keys(loadedImages);
  if (names.length === 0) return;
  const name = names[Math.floor(Math.random()*names.length)];
  const img = loadedImages[name];
  if (!img) return;
  // create img element positioned at bottom center-ish and animate up
  const el = document.createElement('img');
  el.src = img.src;
  el.style.position = 'absolute';
  el.style.width = '84px';
  el.style.height = 'auto';
  el.style.zIndex = 180;
  el.style.left = (20 + Math.random()*(gameArea.getBoundingClientRect().width - 120)) + 'px';
  // start from bottom
  el.style.top = (gameArea.getBoundingClientRect().height - 60) + 'px';
  el.draggable = false;
  gameArea.appendChild(el);
  // animate flight: move up then fall
  const start = Date.now();
  const dur = 3500 + Math.random()*900;
  const sx = parseFloat(el.style.left);
  const sy = parseFloat(el.style.top);
  const vx = (Math.random()-0.5) * 140; // lateral
  function tick(){
    const t = (Date.now() - start)/dur;
    if (t >= 1){ el.remove(); return; }
    // simple throw arc: y = sy - vy*t*dur + gravity * t^2  (we simulate)
    const progress = t;
    // vertical simple ease up then down
    const h = Math.sin(Math.PI*progress) * (gameArea.getBoundingClientRect().height*0.55);
    el.style.top = (sy - h) + 'px';
    el.style.left = (sx + vx * progress) + 'px';
    // rotate a bit
    el.style.transform = `rotate(${(progress*360) % 360}deg)`;
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // allow slicing via pointer detection: check on pointermove we already call checkHits for emojiStage, but real images are in gameArea
  // We'll mark it for detection by attaching dataset
  el.dataset.fruit = name;
  // when sliced by blade, we will detect via global checkHitsOnGameArea -> implemented below
}

/* detect hits on images inside gameArea */
function checkHitsOnImages(clientX, clientY){
  if (!pointerDown) return;
  const list = Array.from(gameArea.querySelectorAll('img'));
  for (const el of list){
    const rect = el.getBoundingClientRect();
    if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom){
      // sliced
      sliceImageFruit(el);
    }
  }
}

/* slicing for image fruit -> create two halves using canvas cropping (fast) */
function sliceImageFruit(imgEl){
  if (!imgEl || imgEl.dataset.sliced) return;
  imgEl.dataset.sliced = '1';
  const rect = imgEl.getBoundingClientRect();
  // create canvas to split image
  const canvasA = document.createElement('canvas');
  const canvasB = document.createElement('canvas');
  const w = rect.width, h = rect.height;
  canvasA.width = canvasB.width = Math.ceil(w/2);
  canvasA.height = canvasB.height = Math.ceil(h);
  // draw halves using offscreen image
  const off = new Image();
  off.crossOrigin = 'anonymous';
  off.onload = ()=>{
    const ax = canvasA.getContext('2d');
    const bx = canvasB.getContext('2d');
    // left half
    ax.drawImage(off, 0, 0, w/2, h, 0, 0, w/2, h);
    // right half
    bx.drawImage(off, w/2, 0, w/2, h, 0, 0, w/2, h);
    // position halves
    const aEl = document.createElement('img');
    const bEl = document.createElement('img');
    aEl.className = 'half'; bEl.className = 'half';
    aEl.style.width = (w/2) + 'px'; bEl.style.width = (w/2) + 'px';
    aEl.style.left = rect.left + 'px'; aEl.style.top = rect.top + 'px';
    bEl.style.left = (rect.left + w/2) + 'px'; bEl.style.top = rect.top + 'px';
    // set src from canvas
    aEl.src = canvasA.toDataURL(); bEl.src = canvasB.toDataURL();
    document.body.appendChild(aEl); document.body.appendChild(bEl);
    // animate halves
    requestAnimationFrame(()=>{
      aEl.style.transition = 'transform 700ms ease, opacity 700ms';
      bEl.style.transition = 'transform 700ms ease, opacity 700ms';
      aEl.style.transform = `translate(${-80}px, ${120}px) rotate(-45deg)`;
      bEl.style.transform = `translate(${80}px, ${120}px) rotate(45deg)`;
      aEl.style.opacity = bEl.style.opacity = 0;
    });
    setTimeout(()=>{ try{ aEl.remove(); bEl.remove(); } catch(e){} },780);
  };
  off.onerror = ()=>{ /* fallback: just remove */ };
  off.src = imgEl.src;
  // remove original
  imgEl.remove();
  // update score
  score += 2;
  scoreEl.textContent = score;
  // score pop
  showScorePop('+2', rect.left + w/2, rect.top + h/2);
}

/* override pointermove to also check images */
window.addEventListener('pointermove', e=>{ if (pointerDown) checkHitsOnImages(e.clientX,e.clientY); });

/* ===== RUN PRELOAD THEN SHOW START ===== */
function init(){
  // show progress initial
  progressText.textContent = `Loading images... 0 / ${IMAGES.length}`;
  bar.style.width = '0%';
  // start emoji loading stage spawn
  startLoadingPhase();
  // preload
  preloadAll(IMAGES, onPreloadProgress).then(()=>{ console.log('[preload] done'); onPreloadDone(); });
  // wire big start hidden initially
  bigStart.style.display = 'none';
  // resize canvas relative to gameArea
  setTimeout(resizeCanvas,80);
}
init();

/* small helper: preload wrapper with onProgress hook implemented earlier */
function preloadAll(list, progressCb){
  return new Promise(resolve=>{
    let done=0, total=list.length;
    progressCb(done,total,'start',true);
    list.forEach(name=>{
      const img = new Image();
      img.onload = ()=>{ loadedImages[name] = img; 
