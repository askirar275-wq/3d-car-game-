<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruit Cut ‚Äî Fixes: preload, slice, gameover</title>
<style>
:root{--bg:#f4f7fb;--panel:#fff;--accent:#22c55e;--btn:#111}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Roboto,Arial,sans-serif;color:#111}
.container{max-width:980px;margin:0 auto;padding:12px}
h1{text-align:center;margin:6px 0 8px}
.hud{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
.stat{background:#fff;padding:8px 12px;border-radius:10px;box-shadow:0 8px 22px rgba(0,0,0,0.06);font-weight:700}
#gameWrapper{position:relative;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#cfeeff,#f9f7ef);height:68vh;min-height:420px}
canvas{position:absolute;inset:0;z-index:5;pointer-events:none}
#gameCanvas{z-index:3}
#fxCanvas{z-index:6}
#loaderOverlay{position:absolute;inset:0;z-index:40;display:flex;align-items:center;justify-content:center;flex-direction:column;background:rgba(255,255,255,0.95)}
#loaderBar{width:260px;height:12px;background:#eee;border-radius:12px;overflow:hidden;margin-top:10px}
#loaderFill{height:100%;width:0;background:linear-gradient(90deg,#22c55e,#06b6d4)}
#bigStart{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:50;background:var(--btn);color:#fff;padding:14px 20px;border-radius:12px;font-weight:800;cursor:pointer;box-shadow:0 12px 30px rgba(0,0,0,0.22)}
.controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;padding:10px;margin-top:8px}
.btn{background:#fff;border:0;padding:10px 14px;border-radius:10px;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.06);font-weight:700}
#gameOverOverlay{position:absolute;inset:0;z-index:70;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6)}
.modalCard{background:#fff;padding:18px;border-radius:12px;text-align:center;min-width:260px}
.consoleBox{position:absolute;right:8px;top:8px;background:rgba(0,0,0,0.78);color:#fff;padding:8px;border-radius:8px;z-index:80;max-height:45%;overflow:auto;font-family:monospace;font-size:12px;display:none}
.small{font-size:13px;color:#666}
</style>
</head>
<body>
  <div class="container">
    <h1>üçâ Fruit Cut ‚Äî Fixed (preload / slice / gameover)</h1>
    <div class="hud">
      <div class="stat">Score: <span id="score">0</span></div>
      <div class="stat">Lives: <span id="lives">3</span></div>
      <div class="stat">Coins: <span id="coins">0</span></div>
      <div style="flex:1"></div>
      <div class="stat">Level: <span id="level">1</span></div>
    </div>

    <div id="gameWrapper">
      <canvas id="gameCanvas"></canvas>
      <canvas id="fxCanvas"></canvas>

      <div id="loaderOverlay">
        <div id="loaderText">Loading images‚Ä¶</div>
        <div id="loaderBar"><div id="loaderFill"></div></div>
        <div class="small" id="loaderStatus">0 / 0</div>
      </div>

      <div id="bigStart">START</div>

      <div id="gameOverOverlay">
        <div class="modalCard">
          <h2>Game Over</h2>
          <p>Score: <span id="goScore">0</span></p>
          <p>Best: <span id="goBest">0</span></p>
          <div style="margin-top:12px">
            <button id="goRestart" class="btn">Play Again</button>
          </div>
        </div>
      </div>

      <div class="consoleBox" id="consoleBox"></div>
    </div>

    <div class="controls">
      <button id="startBtn" class="btn" disabled>Start</button>
      <button id="pauseBtn" class="btn">Pause</button>
      <button id="restartBtn" class="btn">Restart</button>
      <button id="toggleConsole" class="btn">Console</button>
    </div>
  </div>

<script>
/* Single-file fixed game:
   - Preload images (concurrency + createImageBitmap)
   - Improved slice detection (segment vs rect sampling)
   - Shows Game Over when lives==0
   - Offline SW registration (inlined blob)
   Keep your images in /images/ with the names in FRUITS + BOMB.
*/

const FRUITS = ['apple.png','banana.png','cantaloupe.png','guava.png','mango.png','orange.png','papaya.png','pear.png','pineapple.png','plum.png','pomegranate.png','strawberry.png','watermelon.png'];
const BOMB = 'bomb.png';
const IMG_PATH = 'images/';
const ALL = [...FRUITS, BOMB];

// UI
const loaderOverlay = document.getElementById('loaderOverlay');
const loaderFill = document.getElementById('loaderFill');
const loaderStatus = document.getElementById('loaderStatus');
const startBtn = document.getElementById('startBtn');
const bigStart = document.getElementById('bigStart');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');
const toggleConsole = document.getElementById('toggleConsole');
const consoleBox = document.getElementById('consoleBox');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const goRestart = document.getElementById('goRestart');
const goScore = document.getElementById('goScore');
const goBest = document.getElementById('goBest');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const coinsEl = document.getElementById('coins');
const levelEl = document.getElementById('level');

const gameCanvas = document.getElementById('gameCanvas');
const fxCanvas = document.getElementById('fxCanvas');
const ctx = gameCanvas.getContext('2d');
const fx = fxCanvas.getContext('2d');

let areaW=0, areaH=0;
function resize(){
  const rect = document.getElementById('gameWrapper').getBoundingClientRect();
  areaW = Math.floor(rect.width); areaH = Math.floor(rect.height);
  gameCanvas.width = areaW; gameCanvas.height = areaH;
  fxCanvas.width = areaW; fxCanvas.height = areaH;
}
window.addEventListener('resize', resize);

// state
let imageBitmapCache = new Map();
let loaded = 0, failed = [];
let running = false, paused = false;
let score = 0, lives = 3, coins = 0, level = 1;
let spawnTimer = null;
let fruits = []; // {name,img,x,y,w,h,vx,vy,rot,isBomb,sliced,half,born,life}
let particles = [];
let pointerTrail = []; // recent points for blade
const MAX_TRAIL = 28;

// logging
function log(...args){
  const s = '[FruitCut] ' + args.join(' ');
  console.log(s);
  const d = document.createElement('div'); d.textContent = s;
  consoleBox.prepend(d);
}

// preload images with concurrency + createImageBitmap
async function preloadAll(concurrency=3){
  loaderStatus.textContent = `0 / ${ALL.length}`;
  const queue = ALL.slice();
  const cache = await caches.open('fruitcut-cache-v1');
  loaded = 0; failed = [];
  async function worker(){
    while(queue.length){
      const name = queue.shift();
      try{
        // try cache match
        const req = new Request(IMG_PATH + name);
        const cached = await cache.match(req);
        if(cached){
          const blob = await cached.blob();
          const bmp = await createImageBitmap(blob);
          imageBitmapCache.set(name, bmp);
          log('cached', name);
          loaded++; loaderStatus.textContent = `${loaded} / ${ALL.length}`;
          loaderFill.style.width = (loaded / ALL.length * 100) + '%';
          continue;
        }
        // fetch
        const resp = await fetch(IMG_PATH + name, {cache:'no-store'});
        if(!resp.ok) throw new Error('HTTP '+resp.status);
        const blob = await resp.blob();
        // store in cache for offline
        cache.put(req, resp.clone()).catch(()=>{});
        // decode
        const bmp = await createImageBitmap(blob);
        imageBitmapCache.set(name, bmp);
        log('loaded', name);
      }catch(err){
        log('failed', name, err && err.message ? err.message : err);
        failed.push(name);
      } finally {
        loaded++; loaderStatus.textContent = `${loaded} / ${ALL.length}`;
        loaderFill.style.width = (loaded / ALL.length * 100) + '%';
      }
    }
  }
  const workers = [];
  for(let i=0;i<concurrency;i++) workers.push(worker());
  await Promise.all(workers);
}

// spawn function: create a fruit object (drawn on canvas)
function spawnFruit(){
  if(!running || paused) return;
  const isBomb = Math.random() < 0.08;
  const name = isBomb ? BOMB : FRUITS[Math.floor(Math.random()*FRUITS.length)];
  const img = imageBitmapCache.get(name);
  const baseW = Math.max(56, Math.floor(areaW * 0.14));
  const scale = Math.random()*0.6 + 0.9;
  const w = Math.floor(baseW * scale);
  const h = img ? Math.floor(w * (img.height / img.width)) : w;
  const x = Math.random()*(areaW - w) + w/2;
  const y = areaH + h/2 + 10;
  const vy = - (Math.random()*(6) + 12);
  const vx = Math.random()*4 - 2;
  const rot = (Math.random()*40 - 20) * Math.PI/180;
  const obj = {name, img, x, y, w, h, vx, vy, rot, isBomb, sliced:false, born:performance.now()};
  fruits.push(obj);
  // speed up spawn when score grows (optional)
}

// physics update
function updatePhysics(dt){
  for(let i=fruits.length-1;i>=0;i--){
    const f = fruits[i];
    // halves behave as isHalf
    if(f.isHalf){
      f.vy += 0.45;
      f.x += f.vx; f.y += f.vy; f.rot += f.vx*0.02;
      // remove after life
      if(performance.now() - f.born > f.life) fruits.splice(i,1);
      continue;
    }
    f.vy += 0.36; f.x += f.vx; f.y += f.vy; f.rot += f.vx*0.01;
    // remove off bottom
    if(f.y - f.h/2 > areaH + 50){
      // miss: no penalty per requirement
      fruits.splice(i,1);
    }
  }
  // particles update
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.vy += 0.15; p.x += p.vx; p.y += p.vy;
    if(performance.now() - p.born > p.life) particles.splice(i,1);
  }
}

// draw
function drawAll(){
  ctx.clearRect(0,0,areaW,areaH);
  // draw fruits
  for(const f of fruits){
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rot);
    if(f.img && !f.isHalf){
      ctx.drawImage(f.img, -f.w/2, -f.h/2, f.w, f.h);
    } else if(f.img && f.isHalf){
      // draw half by clipping left/right: use scale to flip clip
      ctx.drawImage(f.img, -f.w/2, -f.h/2, f.w, f.h);
    } else {
      ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.ellipse(0,0,f.w/2,f.h/2,0,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // fx canvas: blade trail + particles
  fx.clearRect(0,0,areaW,areaH);

  // particles
  for(const p of particles){
    const age = (performance.now() - p.born) / p.life;
    fx.globalAlpha = Math.max(0, 1 - age);
    fx.fillStyle = p.color;
    fx.beginPath(); fx.arc(p.x,p.y,p.r,0,Math.PI*2); fx.fill();
  }
  fx.globalAlpha = 1;

  // blade trail
  if(pointerTrail.length > 1){
    fx.lineJoin='round'; fx.lineCap='round';
    for(let i=0;i<pointerTrail.length-1;i++){
      const a = pointerTrail[i], b = pointerTrail[i+1];
      const alpha = 1 - i/pointerTrail.length;
      fx.strokeStyle = `rgba(34,197,94,${alpha})`;
      fx.lineWidth = 12 * alpha;
      fx.beginPath(); fx.moveTo(a.x,a.y); fx.lineTo(b.x,b.y); fx.stroke();
    }
  }
}

// slice detection: use segment-vs-rect sampling for reliability
function segmentIntersectsRect(a,b,rect){
  // quick bbox reject
  const minX = Math.min(a.x,b.x), maxX = Math.max(a.x,b.x);
  const minY = Math.min(a.y,b.y), maxY = Math.max(a.y,b.y);
  if(maxX < rect.left || minX > rect.right || maxY < rect.top || minY > rect.bottom) return false;
  // sample along segment
  const steps = 8;
  for(let i=0;i<=steps;i++){
    const t = i/steps;
    const x = a.x + (b.x - a.x) * t;
    const y = a.y + (b.y - a.y) * t;
    if(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) return true;
  }
  return false;
}

function checkSlicesWithTrail(){
  if(pointerTrail.length < 2) return;
  // iterate segments
  for(let s=0;s<pointerTrail.length-1;s++){
    const p1 = pointerTrail[s], p2 = pointerTrail[s+1];
    // check each fruit
    for(let i=fruits.length-1;i>=0;i--){
      const f = fruits[i];
      if(f.sliced) continue;
      const rect = { left: f.x - f.w/2, right: f.x + f.w/2, top: f.y - f.h/2, bottom: f.y + f.h/2 };
      if(segmentIntersectsRect(p1,p2,rect)){
        // slice it
        sliceFruit(f);
        // remove f from fruits list by marking sliced; sliceFruit removes it
      }
    }
  }
}

function sliceFruit(f){
  if(f.sliced) return;
  f.sliced = true;
  // bomb logic
  if(f.isBomb){
    lives = Math.max(0, lives-1);
    spawnParticles(f.x,f.y, '#ff4d4d', 18);
    shakeScreen();
    if(lives <= 0){ endGame(); }
    updateHUD();
  } else {
    score += 10; coins += 1;
    spawnParticles(f.x,f.y, '#ffd54d', 12);
    createHalves(f);
    updateHUD();
  }
  // remove the original
  const idx = fruits.indexOf(f);
  if(idx >= 0) fruits.splice(idx,1);
}

function createHalves(f){
  // push two small half objects (isHalf true) that will be drawn and fall
  const left = {
    img: f.img, x: f.x - (f.w*0.18), y: f.y, w: f.w*0.6, h: f.h*0.6,
    vx: f.vx - 2.4, vy: f.vy*0.2 - 2.6, rot: f.rot - 0.4, isHalf:true, born:performance.now(), life:1000
  };
  const right = {
    img: f.img, x: f.x + (f.w*0.18), y: f.y, w: f.w*0.6, h: f.h*0.6,
    vx: f.vx + 2.4, vy: f.vy*0.2 - 2.6, rot: f.rot + 0.4, isHalf:true, born:performance.now(), life:1000
  };
  fruits.push(left, right);
}

function spawnParticles(cx,cy,color,count=12){
  for(let i=0;i<count;i++){
    particles.push({ x:cx + (Math.random()*10-5), y:cy + (Math.random()*10-5), vx:Math.random()*6-3, vy:Math.random()*-8-1, r:Math.random()*3+2, color, born:performance.now(), life:500 + Math.random()*600 });
  }
}

function shakeScreen(){
  const el = document.getElementById('gameWrapper');
  el.style.transition = 'transform 100ms';
  el.style.transform = `translate(${Math.random()*10-5}px,${Math.random()*6-3}px)`;
  setTimeout(()=>el.style.transform = '',120);
}

// game loop
let last = performance.now();
function loop(now){
  const dt = now - last; last = now;
  if(running && !paused){
    updatePhysics(dt);
    checkSlicesWithTrail();
  }
  drawAll();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// pointer handling
let pointerDown = false;
document.addEventListener('pointerdown', e => {
  pointerDown = true;
  const rect = gameCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  pointerTrail = [{x,y,t:Date.now()}];
});
document.addEventListener('pointermove', e => {
  if(!pointerDown || !running || paused) return;
  const rect = gameCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  pointerTrail.push({x,y,t:Date.now()});
  if(pointerTrail.length > MAX_TRAIL) pointerTrail.shift();
});
document.addEventListener('pointerup', ()=>{ pointerDown = false; pointerTrail = []; });

// spawn interval controls & start/pause/restart/gameover
function startGame(){
  if(running) return;
  running = true; paused = false;
  startBtn.disabled = true; bigStart.style.display = 'none';
  spawnTimer = setInterval(spawnFruit, Math.max(350, 900 - Math.floor(score/50)*20));
  log('Game started');
}
function pauseGame(){ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; }
function restartGame(){ // stop and reset
  running = false; paused = false;
  clearInterval(spawnTimer); spawnTimer = null;
  fruits.forEach(f=>{}); fruits = []; particles = []; pointerTrail = [];
  score = 0; lives = 3; coins = 0; level = 1;
  updateHUD();
  bigStart.style.display = 'block';
  startBtn.disabled = false;
  gameOverOverlay.style.display = 'none';
  log('Restarted');
}
function endGame(){
  running = false; paused = false; clearInterval(spawnTimer); spawnTimer = null;
  goScore.textContent = score;
  const best = Math.max(Number(localStorage.getItem('fc_best')||0), score);
  localStorage.setItem('fc_best', best);
  goBest.textContent = best;
  gameOverOverlay.style.display = 'flex';
  bigStart.style.display = 'block';
  log('Game over, final score', score);
}
function updateHUD(){ scoreEl.textContent = score; livesEl.textContent = lives; coinsEl.textContent = coins; levelEl.textContent = level; }

// improved: when lives change to 0, show Game Over immediately (sliceFruit handles it)
// UI wiring
startBtn.addEventListener('click', startGame);
bigStart.addEventListener('click', startGame);
pauseBtn.addEventListener('click', pauseGame);
restartBtn.addEventListener('click', restartGame);
goRestart.addEventListener('click', ()=>{ gameOverOverlay.style.display='none'; restartGame(); updateHUD(); });
toggleConsole.addEventListener('click', ()=>{ consoleBox.style.display = consoleBox.style.display === 'block' ? 'none' : 'block'; });

// preload + SW register + init UI
async function init(){
  resize();
  // register inline simple SW for caching images (best effort)
  if('serviceWorker' in navigator){
    try{
      const swCode = `
        const CACHE='fruitcut-inline-v1';
        self.addEventListener('install', e => { self.skipWaiting();});
        self.addEventListener('activate', e => { self.clients.claim(); });
        self.addEventListener('fetch', e => {
          e.respondWith(caches.match(e.request).then(r => r || fetch(e.request).then(resp => { caches.open(CACHE).then(c=>c.put(e.request, resp.clone())); return resp; }).catch(()=>caches.match('./'))));
        });
      `;
      const blob = new Blob([swCode], {type: 'text/javascript'});
      const url = URL.createObjectURL(blob);
      await navigator.serviceWorker.register(url);
      log('Service worker registered');
    }catch(err){ log('SW register failed', err && err.message ? err.message : err); }
  }

  // preload with concurrency 3
  try{
    await preloadAll(3);
  }catch(e){ log('preload error', e); }
  // hide loader and enable start
  loaderOverlay.style.display = 'none';
  startBtn.disabled = false;
  bigStart.style.display = 'block';
  updateHUD();
  log('Init done. images loaded: ' + imageBitmapCache.size + ', failed: ' + failed.join(', '));
}
init();

// expose for debugging
window.FruitCut = { start: startGame, pause: pauseGame, restart: restartGame, getState: ()=>({running,score,lives,coins}) };

</script>
</body>
                                          </html>
