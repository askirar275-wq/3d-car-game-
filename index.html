<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruit Cut ‚Äî Final (Single file)</title>
<style>
  :root{
    --bg:#f3f7fb; --panel:#efe9e1; --btn:#111; --btnHover:#333;
    --accent:#22c55e;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  body{margin:10px;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#111}
  .wrap{max-width:720px;margin:0 auto}
  h1{font-size:28px;margin:8px 0 12px}
  .hud{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  .stat{background:#fff;padding:8px 12px;border-radius:12px;box-shadow:0 8px 22px rgba(2,6,23,0.04)}
  #gameWrapper{position:relative;height:520px;border-radius:12px;overflow:hidden;border:1px solid rgba(0,0,0,0.06);
    background:linear-gradient(180deg,#cbeafe,#f6f7fb); /* sky gradient */
    display:flex;align-items:center;justify-content:center;
  }
  #gameArea{position:absolute;inset:0;touch-action:none}
  canvas#bladeCanvas{position:absolute;inset:0;z-index:900;pointer-events:none}
  .fruit{position:absolute;user-select:none;pointer-events:none;will-change:transform,opacity}
  .emoji{position:absolute;font-size:36px;pointer-events:auto;user-select:none}
  .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  button{padding:10px 14px;border-radius:12px;border:0;background:var(--btn);color:#fff;cursor:pointer;font-weight:700;box-shadow:0 10px 22px rgba(0,0,0,0.08)}
  button.ghost{background:#fff;color:#111;border:1px solid #eee;box-shadow:none}
  .modal{position:absolute;inset:10% 6% 10% 6%;display:flex;align-items:center;justify-content:center;z-index:1200}
  .card{background:#fff;padding:20px;border-radius:12px;box-shadow:0 18px 46px rgba(2,6,23,0.12);text-align:center}
  #bigStart{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:200;background:rgba(0,0,0,0.85);color:#fff;padding:14px 22px;border-radius:10px;font-size:18px;cursor:pointer;display:none}
  /* loading UI */
  .loaderWrap{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:1000;pointer-events:none}
  .loader{background:rgba(255,255,255,0.9);padding:18px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.08);min-width:60%}
  .progress{height:10px;background:#eee;border-radius:999px;overflow:hidden;margin-top:10px}
  .progressBar{height:100%;width:0;background:linear-gradient(90deg,#10b981,#06b6d4)}
  /* console overlay */
  #consoleOverlay{position:absolute;left:8px;top:8px;right:8px;height:44%;background:rgba(20,20,20,0.85);color:#fff;padding:10px;border-radius:8px;overflow:auto;z-index:1500;display:none;font-family:monospace;font-size:13px}
  .hudRow{display:flex;gap:8px;flex-wrap:wrap}
  @media (max-width:600px){
    #gameWrapper{height:64vh}
    .loader{min-width:80%}
    .fruit img{width:70px;height:70px}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>üçâ Fruit Cut ‚Äî Final</h1>

  <div class="hud">
    <div class="stat">Score: <strong id="scoreEl">0</strong></div>
    <div class="stat">Lives: <strong id="livesEl">3</strong></div>
    <div class="stat">Coins: <strong id="coinsEl">0</strong></div>
    <div style="flex:1"></div>
    <div class="stat">Level: <strong id="levelEl">1</strong></div>
  </div>

  <div id="gameWrapper" aria-label="Game area">
    <div id="gameArea"></div>
    <canvas id="bladeCanvas"></canvas>

    <!-- loading block -->
    <div class="loaderWrap" id="loaderWrap">
      <div class="loader" id="loaderCard">
        <div style="text-align:center"><strong id="loadingText">Loading images...</strong></div>
        <div class="progress" aria-hidden="true"><div class="progressBar" id="progressBar"></div></div>
        <div style="text-align:center;margin-top:8px" id="progressCount">0 / 0</div>
      </div>
    </div>

    <!-- big start -->
    <div id="bigStart">START</div>

    <!-- console -->
    <div id="consoleOverlay"></div>
  </div>

  <div class="controls">
    <button id="startBtn" class="ghost">Start</button>
    <button id="pauseBtn" class="ghost" disabled>Pause</button>
    <button id="restartBtn" class="ghost">Restart</button>
    <button id="shopBtn" class="ghost">Shop</button>
    <button id="toggleConsole" class="ghost">Toggle Console</button>
  </div>
  <p style="color:#666;margin-top:12px">Tip: Slice fruits by swiping. Bomb sliced ‚Üí lose life. If lives = 0, Game Over.</p>
</div>

<!-- simple shop modal skeleton -->
<div id="shopModal" class="modal" style="display:none">
  <div class="card">
    <h3>Shop (unlock backgrounds / blades)</h3>
    <p>Work in progress ‚Äî coins will be used here.</p>
    <div style="margin-top:12px">
      <button id="shopCloseBtn" class="ghost">Close</button>
    </div>
  </div>
</div>

<script>
/* Fruit Cut ‚Äî single-file final (bouncing emoji during preload + slice, preloads images from images/) */

(function(){
  // CONFIG
  const IMG_FOLDER = "images/"; // keep images in images/ folder
  const FRUITS = [
    "apple.png","banana.png","cantaloupe.png","guava.png","mango.png",
    "orange.png","papaya.png","pear.png","pineapple.png","plum.png",
    "pomegranate.png","strawberry.png","watermelon.png"
  ];
  const BOMB = "bomb.png";
  const ALL_IMAGES = FRUITS.concat([BOMB]);
  const SPAWN_INTERVAL_MS = 850; // how often new fruit spawn (ms)
  const FRUIT_SIZE = 92; // px base size (you asked smaller/bigger, change here)
  const GRAVITY = 0.26;
  const SLICE_THRESHOLD = 16; // min speed to consider slice

  // DOM
  const gameArea = document.getElementById('gameArea');
  const bladeCanvas = document.getElementById('bladeCanvas');
  const scoreEl = document.getElementById('scoreEl');
  const livesEl = document.getElementById('livesEl');
  const coinsEl = document.getElementById('coinsEl');
  const levelEl = document.getElementById('levelEl');
  const loaderWrap = document.getElementById('loaderWrap');
  const progressBar = document.getElementById('progressBar');
  const progressCount = document.getElementById('progressCount');
  const loadingText = document.getElementById('loadingText');
  const bigStart = document.getElementById('bigStart');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const shopBtn = document.getElementById('shopBtn');
  const shopModal = document.getElementById('shopModal');
  const shopCloseBtn = document.getElementById('shopCloseBtn');
  const consoleOverlay = document.getElementById('consoleOverlay');
  const toggleConsole = document.getElementById('toggleConsole');

  // canvas setup
  const bctx = bladeCanvas.getContext('2d');
  function resizeCanvas(){
    const r = gameArea.getBoundingClientRect();
    bladeCanvas.width = Math.max(1, Math.floor(r.width));
    bladeCanvas.height = Math.max(1, Math.floor(r.height));
  }
  window.addEventListener('resize', resizeCanvas);
  setTimeout(resizeCanvas,60);

  // internal console
  function log(...args){
    const t = new Date().toLocaleTimeString();
    const line = "["+t+"] " + args.join(" ");
    console.log(line);
    consoleOverlay.innerText = (consoleOverlay.innerText ? consoleOverlay.innerText + "\n" : "") + line;
    consoleOverlay.scrollTop = consoleOverlay.scrollHeight;
  }
  toggleConsole.addEventListener('click', ()=> {
    consoleOverlay.style.display = consoleOverlay.style.display === 'none' ? 'block' : 'none';
  });

  // game state
  let score = 0, lives = 3, coins = 0, level = 1;
  let running = false, spawnTimer = null;
  let activeFruits = []; // objects
  let IMAGE_CACHE = {}; // filename -> HTMLImageElement

  // blade effect / pointer tracking
  let bladePoints = [];
  const MAX_POINTS = 20;
  function addBladePoint(x,y){
    const r = gameArea.getBoundingClientRect();
    bladePoints.push({x:x-r.left, y:y-r.top, t:Date.now()});
    if (bladePoints.length > MAX_POINTS) bladePoints.shift();
  }
  function clearBlade(){
    bladePoints = [];
  }
  function drawBlade(){
    bctx.clearRect(0,0,bladeCanvas.width, bladeCanvas.height);
    if (bladePoints.length < 2) { requestAnimationFrame(drawBlade); return; }
    bctx.lineJoin = 'round';
    for(let i=0;i<bladePoints.length-1;i++){
      const p1=bladePoints[i], p2=bladePoints[i+1];
      const age = Date.now() - p2.t;
      const alpha = Math.max(0, 1 - age/350);
      bctx.strokeStyle = `rgba(34,197,94,${0.9*alpha})`;
      bctx.lineWidth = 20 * alpha;
      bctx.beginPath(); bctx.moveTo(p1.x,p1.y); bctx.lineTo(p2.x,p2.y); bctx.stroke();
    }
    requestAnimationFrame(drawBlade);
  }
  drawBlade();

  // pointer events
  let isPointerDown = false;
  function onPointerDown(e){
    isPointerDown = true; addBladePoint(e.clientX, e.clientY);
    lastPointer = {x:e.clientX, y:e.clientY, t:Date.now()};
  }
  function onPointerMove(e){
    if (!isPointerDown) return;
    addBladePoint(e.clientX, e.clientY);
    // check slice collision with fruits
    const p = {x:e.clientX, y:e.clientY};
    checkSliceAgainstFruits(p);
    lastPointer = {x:e.clientX, y:e.clientY, t:Date.now()};
  }
  function onPointerUp(e){
    isPointerDown = false;
    clearBlade();
  }
  window.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
  window.addEventListener('pointercancel', onPointerUp);

  // preload images with progress
  async function preloadImages(list, onProgress){
    const total = list.length; let loaded = 0;
    for(const name of list){
      try{
        const img = await loadImageOnce(IMG_FOLDER + name);
        IMAGE_CACHE[name] = img;
        loaded++;
        onProgress && onProgress(loaded, total, name);
      }catch(err){
        log("[preload] failed", name, err.message || err);
        // try fallback: maybe image is at root or different path; skip but continue
      }
    }
    return IMAGE_CACHE;
  }
  function loadImageOnce(src){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=> resolve(img);
      img.onerror = ()=> reject(new Error("failed: "+src));
      img.src = src;
    });
  }

  // show bouncing emoji during preload
  let emojiPool = [];
  function startEmojiBounce(){
    // create few emojis in gameArea that bounce and can be sliced
    const emojis = ["üçâ","üçé","üçå","üçä","üçì"];
    for(let i=0;i<6;i++){
      const el = document.createElement('div');
      el.className = 'emoji';
      el.style.left = (20 + Math.random()*60) + "%";
      el.style.top = (50 + Math.random()*20) + "%";
      el.style.fontSize = (28 + Math.random()*18) + "px";
      el.innerText = emojis[Math.floor(Math.random()*emojis.length)];
      el.dataset.bounceVy = -6 - Math.random()*5;
      el.dataset.vx = (Math.random()-0.5)*2;
      el.style.zIndex = 700;
      gameArea.appendChild(el);
      emojiPool.push({el, vx:parseFloat(el.dataset.vx), vy:parseFloat(el.dataset.bounceVy)});
    }
    requestAnimationFrame(stepEmoji);
  }
  function stepEmoji(){
    if (Object.keys(IMAGE_CACHE).length >= ALL_IMAGES.length) return; // stop when loaded
    const r = gameArea.getBoundingClientRect();
    for(const item of emojiPool){
      const el = item.el;
      let x = parseFloat(el.style.left) || 0;
      let y = parseFloat(el.style.top) || 0;
      // units were percent; convert to px movement
      x = x; y = y + item.vy; // vy in px per frame approx
      item.vy += 0.35; // gravity tiny
      if (y > 95){ item.vy = -6 - Math.random()*4; y = 95; } // bounce
      if (x < 2 || x > 96) item.vx *= -1;
      el.style.top = y + "%";
      el.style.left = x + "%";
    }
    setTimeout(()=>requestAnimationFrame(stepEmoji), 16);
  }

  // spawn fruits when running
  function spawnFruit(){
    if (!running) return;
    // pick random fruit from available cache
    const names = Object.keys(IMAGE_CACHE);
    if (names.length === 0) return;
    const name = names[Math.floor(Math.random()*names.length)];
    const isBomb = name === BOMB;
    const el = document.createElement('div');
    el.className = 'fruit';
    el.style.width = FRUIT_SIZE + "px";
    el.style.height = FRUIT_SIZE + "px";
    el.style.left = (10 + Math.random()*80) + "%";
    el.style.bottom = "-120px";
    el.style.zIndex = 600;
    const img = document.createElement('img');
    img.draggable = false;
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "contain";
    img.src = IMAGE_CACHE[name] ? IMAGE_CACHE[name].src : (IMG_FOLDER+name);
    el.appendChild(img);
    gameArea.appendChild(el);

    // physics
    const vx = (Math.random()-0.5) * 4; // horizontal velocity
    const vy = - (10 + Math.random()*6); // upward throw
    const rot = (Math.random()-0.5)*40;
    const obj = {
      el, img, name, isBomb, x:0, y:0, vx, vy, rot, angle:0, w:FRUIT_SIZE, h:FRUIT_SIZE, sliced:false
    };
    activeFruits.push(obj);
  }

  // update loop for fruits physics
  function updateLoop(){
    const dt = 16;
    for(let i=activeFruits.length-1;i>=0;i--){
      const f = activeFruits[i];
      if (f.sliced) continue; // sliced handled separately
      // update
      f.vy += GRAVITY;
      f.x += f.vx;
      f.vy = f.vy;
      f.angle += f.vx * 0.6;
      // apply to DOM
      const r = gameArea.getBoundingClientRect();
      // compute pixel values from percent left if set
      const leftPercent = parseFloat(f.el.style.left) || 0;
      const leftPx = Math.round((leftPercent/100) * r.width + f.x);
      const bottomPx = parseFloat(f.el.style.bottom) || -120;
      const newBottom = bottomPx + f.vy;
      f.el.style.left = ( (leftPx) / r.width * 100 ) + "%";
      f.el.style.bottom = newBottom + "px";
      f.el.style.transform = `rotate(${f.angle}deg)`;
      // detect off-screen (missed) - when bottom < -200 or top > area height
      if (newBottom < -400 || newBottom > r.height + 200){
        // remove
        f.el.remove();
        activeFruits.splice(i,1);
        // if it was a fruit (not bomb) and not sliced -> it's missed. As requested: missing fruit -> nothing (you asked?), we'll make missing fruit do nothing (no life loss). Bomb slice loses life only.
      }
    }
    requestAnimationFrame(updateLoop);
  }
  updateLoop();

  // check slicing: we compare pointer segment to fruit rect
  function checkSliceAgainstFruits(p){
    if (!p) return;
    // create small line segment from last few bladePoints
    if (bladePoints.length < 2) return;
    const last = bladePoints[bladePoints.length-1];
    const prev = bladePoints[bladePoints.length-2];
    const x1 = prev.x, y1 = prev.y, x2 = last.x, y2 = last.y;
    for(let i=activeFruits.length-1;i>=0;i--){
      const f = activeFruits[i];
      if (f.sliced) continue;
      const rect = f.el.getBoundingClientRect();
      const r = bladeCanvas.getBoundingClientRect();
      // translate coordinates
      const seg = {x1,y1,x2,y2};
      // simple line-rect intersection:
      if (lineIntersectsRect(seg, rect, r)){
        // slice it
        sliceFruit(f);
      }
    }
  }

  function lineIntersectsRect(seg, rect, canvasRect){
    // seg coords are relative to gameArea (we stored them that way)
    const x1 = seg.x1 + canvasRect.left, y1 = seg.y1 + canvasRect.top;
    const x2 = seg.x2 + canvasRect.left, y2 = seg.y2 + canvasRect.top;
    if (x1 < rect.left && x2 < rect.left) return false;
    if (x1 > rect.right && x2 > rect.right) return false;
    if (y1 < rect.top && y2 < rect.top) return false;
    if (y1 > rect.bottom && y2 > rect.bottom) return false;
    // approximate: check distance from segment to rect center
    const cx = (rect.left + rect.right)/2, cy = (rect.top + rect.bottom)/2;
    // using simple point to segment distance
    const dist = pointToSegmentDistance({x:cx,y:cy},{x:x1,y:y1},{x:x2,y:y2});
    return dist < Math.max(rect.width, rect.height)*0.7;
  }
  function pointToSegmentDistance(p, v, w){
    const l2 = (v.x-w.x)*(v.x-w.x) + (v.y-w.y)*(v.y-w.y);
    if (l2===0) return Math.hypot(p.x-v.x,p.y-v.y);
    let t = ((p.x-v.x)*(w.x-v.x) + (p.y-v.y)*(w.y-v.y))/l2;
    t = Math.max(0, Math.min(1,t));
    const projx = v.x + t*(w.x-v.x), projy = v.y + t*(w.y-v.y);
    return Math.hypot(p.x-projx, p.y-projy);
  }

  // slice fruit: show two halves and apply physics, update score or lives
  function sliceFruit(f){
    f.sliced = true;
    const name = f.name;
    const isBomb = f.isBomb;
    // remove original
    const rect = f.el.getBoundingClientRect();
    // create halves
    const halfA = document.createElement('div');
    const halfB = document.createElement('div');
    halfA.style.position = 'absolute'; halfB.style.position='absolute';
    halfA.style.width = rect.width + 'px'; halfA.style.height = rect.height + 'px';
    halfB.style.width = rect.width + 'px'; halfB.style.height = rect.height + 'px';
    halfA.style.left = rect.left + 'px'; halfA.style.top = rect.top + 'px';
    halfB.style.left = rect.left + 'px'; halfB.style.top = rect.top + 'px';
    halfA.style.zIndex = 1000; halfB.style.zIndex = 1000;
    halfA.style.pointerEvents = 'none'; halfB.style.pointerEvents = 'none';
    // use same image as background
    const src = (IMAGE_CACHE[name] && IMAGE_CACHE[name].src) ? IMAGE_CACHE[name].src : (IMG_FOLDER+name);
    halfA.style.backgroundImage = `url('${src}')`; halfA.style.backgroundSize='cover';
    halfB.style.backgroundImage = `url('${src}')`; halfB.style.backgroundSize='cover';
    // clip halves using clip-path
    halfA.style.clipPath = 'polygon(0 0, 100% 0, 100% 50%, 0 50%)'; // top half
    halfB.style.clipPath = 'polygon(0 50%, 100% 50%, 100% 100%, 0 100%)'; // bottom half
    document.body.appendChild(halfA); document.body.appendChild(halfB);
    // animate halves outward
    const force = 4 + Math.random()*3;
    const ang = (Math.random()*60 + 20) * (Math.random()<0.5?-1:1);
    let vyA = -6 - Math.random()*4, vxA = -force;
    let vyB = -6 - Math.random()*4, vxB = force;
    let rotA = -20, rotB = 20;
    // simple physics loop
    let tick = 0;
    const gravity = 0.3;
    const anim = setInterval(()=>{
      tick++;
      vyA += gravity; vyB += gravity;
      const topA = parseFloat(halfA.style.top) + vyA;
      const leftA = parseFloat(halfA.style.left) + vxA;
      const topB = parseFloat(halfB.style.top) + vyB;
      const leftB = parseFloat(halfB.style.left) + vxB;
      halfA.style.top = topA + 'px'; halfA.style.left = leftA + 'px'; halfA.style.transform = `rotate(${rotA + tick*3}deg)`;
      halfB.style.top = topB + 'px'; halfB.style.left = leftB + 'px'; halfB.style.transform = `rotate(${rotB - tick*3}deg)`;
      // fade out
      if (tick > 80){ halfA.style.opacity = 1 - (tick-80)/20; halfB.style.opacity = 1 - (tick-80)/20; }
      if (tick > 100){
        clearInterval(anim); halfA.remove(); halfB.remove();
      }
    },16);

    // remove original element and from activeFruits
    f.el.remove();
    const idx = activeFruits.indexOf(f); if (idx !== -1) activeFruits.splice(idx,1);

    // handle bomb or fruit
    if (isBomb){
      lives = Math.max(0, lives-1); updateHUD();
      log("Bomb sliced. lives=" + lives);
      if (lives <= 0) gameOver();
    } else {
      score += 10; coins += 1; updateHUD();
      log("Fruit sliced: " + name);
    }
  }

  function updateHUD(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    coinsEl.textContent = coins;
    levelEl.textContent = level;
  }

  function gameOver(){
    running = false;
    clearInterval(spawnTimer);
    bigStart.style.display = 'block';
    // show game over card (simple alert for now)
    setTimeout(()=>{ alert("Game Over! Score: " + score); },100);
  }

  // start / pause / restart
  function startGame(){
    if (running) return;
    running = true;
    bigStart.style.display = 'none';
    pauseBtn.disabled = false;
    spawnTimer = setInterval(spawnFruit, SPAWN_INTERVAL_MS);
    log("Game started");
  }
  fu
