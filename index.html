<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruit Cut ‚Äî Fixed Preload & Gameover</title>
<style>
:root{--bg:#f4f7fb;--panel:#fff;--accent:#22c55e;--btn:#111}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Roboto,Arial,sans-serif;color:#111}
.container{max-width:980px;margin:0 auto;padding:12px}
h1{text-align:center;margin:6px 0 8px}
.hud{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
.stat{background:#fff;padding:8px 12px;border-radius:10px;box-shadow:0 8px 22px rgba(0,0,0,0.06);font-weight:700}
#gameWrapper{position:relative;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#cfeeff,#f9f7ef);height:68vh;min-height:420px}
canvas{position:absolute;inset:0;z-index:3;pointer-events:none}
#fxCanvas{z-index:6}
#loaderOverlay{position:absolute;inset:0;z-index:40;display:flex;align-items:center;justify-content:center;flex-direction:column;background:rgba(255,255,255,0.95)}
#loaderBar{width:260px;height:12px;background:#eee;border-radius:12px;overflow:hidden;margin-top:10px}
#loaderFill{height:100%;width:0;background:linear-gradient(90deg,#22c55e,#06b6d4)}
#bigStart{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:50;background:var(--btn);color:#fff;padding:14px 20px;border-radius:12px;font-weight:800;cursor:pointer;box-shadow:0 12px 30px rgba(0,0,0,0.22)}
.controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;padding:10px;margin-top:8px}
.btn{background:#fff;border:0;padding:10px 14px;border-radius:10px;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.06);font-weight:700}
#gameOverOverlay{position:absolute;inset:0;z-index:70;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6)}
.modalCard{background:#fff;padding:18px;border-radius:12px;text-align:center;min-width:260px}
.consoleBox{position:absolute;right:8px;top:8px;background:rgba(0,0,0,0.78);color:#fff;padding:8px;border-radius:8px;z-index:80;max-height:45%;overflow:auto;font-family:monospace;font-size:12px;display:none}
.small{font-size:13px;color:#666}
</style>
</head>
<body>
  <div class="container">
    <h1>üçâ Fruit Cut ‚Äî Fixed Preload & Gameover</h1>
    <div class="hud">
      <div class="stat">Score: <span id="score">0</span></div>
      <div class="stat">Lives: <span id="lives">3</span></div>
      <div class="stat">Coins: <span id="coins">0</span></div>
      <div style="flex:1"></div>
      <div class="stat">Level: <span id="level">1</span></div>
    </div>

    <div id="gameWrapper">
      <canvas id="gameCanvas"></canvas>
      <canvas id="fxCanvas"></canvas>

      <div id="loaderOverlay">
        <div id="loaderText">Loading images‚Ä¶</div>
        <div id="loaderBar"><div id="loaderFill"></div></div>
        <div class="small" id="loaderStatus">0 / 0</div>
      </div>

      <div id="bigStart">START</div>

      <div id="gameOverOverlay">
        <div class="modalCard">
          <h2>Game Over</h2>
          <p>Score: <span id="goScore">0</span></p>
          <p>Best: <span id="goBest">0</span></p>
          <div style="margin-top:12px">
            <button id="goRestart" class="btn">Play Again</button>
          </div>
        </div>
      </div>

      <div class="consoleBox" id="consoleBox"></div>
    </div>

    <div class="controls">
      <button id="startBtn" class="btn" disabled>Start</button>
      <button id="pauseBtn" class="btn">Pause</button>
      <button id="restartBtn" class="btn">Restart</button>
      <button id="toggleConsole" class="btn">Console</button>
    </div>
  </div>

<script>
/* Updated: preload fix + removed blob-SW registration to avoid GitHub Pages errors.
   Keep images in images/ folder. Names used (you can add more):
   apple.png banana.png cantaloupe.png guava.png mango.png orange.png papaya.png
   pear.png pineapple.png plum.png pomegranate.png strawberry.png watermelon.png bomb.png
*/

const FRUITS = ['apple.png','banana.png','cantaloupe.png','guava.png','mango.png','orange.png','papaya.png','pear.png','pineapple.png','plum.png','pomegranate.png','strawberry.png','watermelon.png'];
const BOMB = 'bomb.png';
const IMG_PATH = 'images/';
const ALL = [...FRUITS, BOMB];

// UI elements
const loaderOverlay = document.getElementById('loaderOverlay');
const loaderFill = document.getElementById('loaderFill');
const loaderStatus = document.getElementById('loaderStatus');
const startBtn = document.getElementById('startBtn');
const bigStart = document.getElementById('bigStart');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');
const toggleConsole = document.getElementById('toggleConsole');
const consoleBox = document.getElementById('consoleBox');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const goRestart = document.getElementById('goRestart');
const goScore = document.getElementById('goScore');
const goBest = document.getElementById('goBest');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const coinsEl = document.getElementById('coins');
const levelEl = document.getElementById('level');

const gameCanvas = document.getElementById('gameCanvas');
const fxCanvas = document.getElementById('fxCanvas');
const ctx = gameCanvas.getContext('2d');
const fx = fxCanvas.getContext('2d');

let areaW=0, areaH=0;
function resize(){
  const rect = document.getElementById('gameWrapper').getBoundingClientRect();
  areaW = Math.floor(rect.width); areaH = Math.floor(rect.height);
  gameCanvas.width = areaW; gameCanvas.height = areaH;
  fxCanvas.width = areaW; fxCanvas.height = areaH;
}
window.addEventListener('resize', resize);

// state
let imageBitmapCache = new Map();
let loaded = 0, failed = [];
let running = false, paused = false;
let score = 0, lives = 3, coins = 0, level = 1;
let spawnTimer = null;
let fruits = [];
let particles = [];
let pointerTrail = [];
const MAX_TRAIL = 28;

// logger
function log(...args){
  const s = '[FruitCut] ' + args.join(' ');
  console.log(s);
  const d = document.createElement('div'); d.textContent = s;
  consoleBox.prepend(d);
}

// PRELOAD (fixed): fetch -> blob -> cache.put(new Response(blob)) -> createImageBitmap(blob)
async function preloadAll(concurrency=3){
  loaderStatus.textContent = `0 / ${ALL.length}`;
  const queue = ALL.slice();
  const cache = await caches.open('fruitcut-cache-v1');
  loaded = 0; failed = [];
  async function worker(){
    while(queue.length){
      const name = queue.shift();
      try{
        const reqUrl = IMG_PATH + name;
        // try cache first
        const match = await cache.match(reqUrl);
        if(match){
          const blob = await match.blob();
          const bmp = await createImageBitmap(blob);
          imageBitmapCache.set(name, bmp);
          log('cached', name);
          loaded++; loaderFill.style.width = (loaded / ALL.length * 100) + '%';
          loaderStatus.textContent = `${loaded} / ${ALL.length}`;
          continue;
        }
        // fetch remote
        const resp = await fetch(reqUrl, {cache:'no-store'});
        if(!resp.ok) throw new Error('HTTP ' + resp.status);
        // read blob ONCE
        const blob = await resp.blob();
        // store blob in cache (use new Response from blob)
        try{
          await cache.put(reqUrl, new Response(blob, {headers:{'Content-Type': blob.type || 'image/png'}}));
        }catch(e){ /* cache put may fail on some hosts, ignore */ }
        // decode
        const bmp = await createImageBitmap(blob);
        imageBitmapCache.set(name, bmp);
        log('loaded', name);
      }catch(err){
        log('failed', name, err && err.message ? err.message : err);
        failed.push(name);
      } finally {
        loaded++; loaderStatus.textContent = `${loaded} / ${ALL.length}`;
        loaderFill.style.width = (loaded / ALL.length * 100) + '%';
      }
    }
  }
  const workers = [];
  for(let i=0;i<concurrency;i++) workers.push(worker());
  await Promise.all(workers);
}

// spawn object
function spawnFruit(){
  if(!running || paused) return;
  const isBomb = Math.random() < 0.08;
  const name = isBomb ? BOMB : FRUITS[Math.floor(Math.random()*FRUITS.length)];
  const img = imageBitmapCache.get(name) || null;
  const baseW = Math.max(56, Math.floor(areaW * 0.16)); // slightly larger
  const scale = Math.random()*0.6 + 0.9;
  const w = Math.floor(baseW * scale);
  const h = img ? Math.floor(w * (img.height / img.width)) : w;
  const x = Math.random()*(areaW - w) + w/2;
  const y = areaH + h/2 + 10;
  const vy = - (Math.random()*(6) + 12);
  const vx = Math.random()*4 - 2;
  const rot = (Math.random()*40 - 20) * Math.PI/180;
  const obj = {name, img, x, y, w, h, vx, vy, rot, isBomb, sliced:false, born:performance.now()};
  fruits.push(obj);
}

// physics + rendering
function updatePhysics(dt){
  for(let i=fruits.length-1;i>=0;i--){
    const f = fruits[i];
    if(f.isHalf){
      f.vy += 0.45;
      f.x += f.vx; f.y += f.vy; f.rot += f.vx*0.02;
      if(performance.now() - f.born > f.life) fruits.splice(i,1);
      continue;
    }
    f.vy += 0.36; f.x += f.vx; f.y += f.vy; f.rot += f.vx*0.01;
    if(f.y - f.h/2 > areaH + 50) fruits.splice(i,1);
  }
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; p.vy += 0.15; p.x += p.vx; p.y += p.vy;
    if(performance.now() - p.born > p.life) particles.splice(i,1);
  }
}

function drawAll(){
  ctx.clearRect(0,0,areaW,areaH);
  for(const f of fruits){
    ctx.save(); ctx.translate(f.x,f.y); ctx.rotate(f.rot);
    if(f.img && !f.isHalf){
      ctx.drawImage(f.img, -f.w/2, -f.h/2, f.w, f.h);
    } else if(f.img && f.isHalf){
      ctx.drawImage(f.img, -f.w/2, -f.h/2, f.w, f.h);
    } else {
      ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.ellipse(0,0,f.w/2,f.h/2,0,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  fx.clearRect(0,0,areaW,areaH);
  for(const p of particles){
    const age = (performance.now() - p.born) / p.life; fx.globalAlpha = Math.max(0,1-age);
    fx.fillStyle = p.color; fx.beginPath(); fx.arc(p.x,p.y,p.r,0,Math.PI*2); fx.fill();
  }
  fx.globalAlpha = 1;
  if(pointerTrail.length > 1){
    fx.lineJoin='round'; fx.lineCap='round';
    for(let i=0;i<pointerTrail.length-1;i++){
      const a = pointerTrail[i], b = pointerTrail[i+1];
      const alpha = 1 - i/pointerTrail.length;
      fx.strokeStyle = `rgba(34,197,94,${alpha})`;
      fx.lineWidth = 12 * alpha;
      fx.beginPath(); fx.moveTo(a.x,a.y); fx.lineTo(b.x,b.y); fx.stroke();
    }
  }
}

function segmentIntersectsRect(a,b,rect){
  const minX = Math.min(a.x,b.x), maxX = Math.max(a.x,b.x);
  const minY = Math.min(a.y,b.y), maxY = Math.max(a.y,b.y);
  if(maxX < rect.left || minX > rect.right || maxY < rect.top || minY > rect.bottom) return false;
  const steps = 8;
  for(let i=0;i<=steps;i++){
    const t = i/steps;
    const x = a.x + (b.x - a.x) * t;
    const y = a.y + (b.y - a.y) * t;
    if(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) return true;
  }
  return false;
}

function checkSlicesWithTrail(){
  if(pointerTrail.length < 2) return;
  for(let s=0;s<pointerTrail.length-1;s++){
    const p1 = pointerTrail[s], p2 = pointerTrail[s+1];
    for(let i=fruits.length-1;i>=0;i--){
      const f = fruits[i];
      if(f.sliced) continue;
      const rect = { left: f.x - f.w/2, right: f.x + f.w/2, top: f.y - f.h/2, bottom: f.y + f.h/2 };
      if(segmentIntersectsRect(p1,p2,rect)){
        sliceFruit(f);
      }
    }
  }
}

function sliceFruit(f){
  if(f.sliced) return;
  f.sliced = true;
  if(f.isBomb){
    lives = Math.max(0, lives-1);
    spawnParticles(f.x,f.y, '#ff4d4d', 18);
    shakeScreen();
    if(lives <= 0){ endGame(); }
    updateHUD();
  } else {
    score += 10; coins += 1;
    spawnParticles(f.x,f.y, '#ffd54d', 12);
    createHalves(f);
    updateHUD();
  }
  const idx = fruits.indexOf(f); if(idx>=0) fruits.splice(idx,1);
}

function createHalves(f){
  const left = {
    img: f.img, x: f.x - (f.w*0.18), y: f.y, w: f.w*0.6, h: f.h*0.6,
    vx: f.vx - 2.4, vy: f.vy*0.2 - 2.6, rot: f.rot - 0.4, isHalf:true, born:performance.now(), life:1000
  };
  const right = {
    img: f.img, x: f.x + (f.w*0.18), y: f.y, w: f.w*0.6, h: f.h*0.6,
    vx: f.vx + 2.4, vy: f.vy*0.2 - 2.6, rot: f.rot + 0.4, isHalf:true, born:performance.now(), life:1000
  };
  fruits.push(left, right);
}

function spawnParticles(cx,cy,color,count=12){
  for(let i=0;i<count;i++){
    particles.push({ x:cx + (Math.random()*10-5), y:cy + (Math.random()*10-5), vx:Math.random()*6-3, vy:Math.random()*-8-1, r:Math.random()*3+2, color, born:performance.now(), life:500 + Math.random()*600 });
  }
}

function shakeScreen(){
  const el = document.getElementById('gameWrapper');
  el.style.transition = 'transform 100ms';
  el.style.transform = `translate(${Math.random()*10-5}px,${Math.random()*6-3}px)`;
  setTimeout(()=>el.style.transform = '',120);
}

// main loop
let last = performance.now();
function loop(now){
  const dt = now - last; last = now;
  if(running && !paused){
    updatePhysics(dt);
    checkSlicesWithTrail();
  }
  drawAll();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// pointer events
let pointerDown = false;
document.addEventListener('pointerdown', e => {
  pointerDown = true;
  const rect = gameCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  pointerTrail = [{x,y,t:Date.now()}];
});
document.addEventListener('pointermove', e => {
  if(!pointerDown || !running || paused) return;
  const rect = gameCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  pointerTrail.push({x,y,t:Date.now()});
  if(pointerTrail.length > MAX_TRAIL) pointerTrail.shift();
});
document.addEventListener('pointerup', ()=>{ pointerDown = false; pointerTrail = []; });

// controls & game flow
function startGame(){
  if(running) return;
  running = true; paused = false;
  startBtn.disabled = true; bigStart.style.display = 'none';
  // spawn faster depending on score:
  spawnTimer = setInterval(spawnFruit, Math.max(300, 800 - Math.floor(score/50)*20));
  log('Game started');
}
function pauseGame(){ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; }
function restartGame(){ running=false; paused=false; clearInterval(spawnTimer); spawnTimer=null; fruits=[]; particles=[]; pointerTrail=[]; score=0; lives=3; coins=0; level=1; updateHUD(); bigStart.style.display='block'; startBtn.disabled=false; gameOverOverlay.style.display='none'; log('Restarted'); }
function endGame(){
  running=false; paused=false; clearInterval(spawnTimer); spawnTimer=null;
  goScore.textContent = score;
  const best = Math.max(Number(localStorage.getItem('fc_best')||0), score);
  localStorage.setItem('fc_best', best);
  goBest.textContent = best;
  gameOverOverlay.style.display = 'flex';
  bigStart.style.display = 'block';
  log('Game over', score);
}
function updateHUD(){ scoreEl.textContent = score; livesEl.textContent = lives; coinsEl.textContent = coins; levelEl.textContent = level; }

// UI wiring
startBtn.addEventListener('click', startGame);
bigStart.addEventListener('click', startGame);
pauseBtn.addEventListener('click', pauseGame);
restartBtn.addEventListener('click', restartGame);
goRestart.addEventListener('click', ()=>{ gameOverOverlay.style.display='none'; restartGame(); updateHUD();});
toggleConsole.addEventListener('click', ()=>{ consoleBox.style.display = consoleBox.style.display === 'block' ? 'none' : 'block'; });

// init: resize + preload
async function init(){
  resize();
  // preload but handle errors gracefully
  try{
    await preloadAll(3);
  }catch(e){ log('preload error', e && e.message ? e.message : e); }
  loaderOverlay.style.display = 'none';
  startBtn.disabled = false; bigStart.style.display = 'block';
  updateHUD();
  log('Init done. images loaded:', imageBitmapCache.size, 'failed:', failed.join(','));
}
init();

// expose debug
window.FruitCut = { start:startGame, pause:pauseGame, restart:restartGame, state: ()=>({running,score,lives}) };
</script>
</body>
  </html>
